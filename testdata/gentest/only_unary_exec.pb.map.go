// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: testdata/gentest/only_unary_exec.proto

package gentest

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	math "math"

	//protoc-gen-map packages
	bytes "bytes"
	context "context"
	sql "database/sql"
	mapper "github.com/jackskj/protoc-gen-map/mapper"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	log "log"
	sync "sync"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Code generated by protoc-gen-map. DO NOT EDIT.
// To Use:
// 1. Instantiate MapperServers with sql.DB connection
// 2. Register MapperServer as the gRPC service server
// 3. Begin serving

type OnlyExecServiceMapServer struct {
	DB      *sql.DB
	Dialect string

	InsertMapper    *mapper.Mapper
	InsertCallbacks OnlyExecServiceInsertCallbacks

	mapperGenMux sync.Mutex
}

type OnlyExecServiceInsertCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *OnlyExec) error
	AfterQueryCallback  []func(queryString string, req *OnlyExec, resp *OnlyExec) error
	Cache               func(queryString string, req *OnlyExec) (*OnlyExec, error)
}

func (m *OnlyExecServiceMapServer) RegisterInsertBeforeQueryCallback(callbacks ...func(queryString string, req *OnlyExec) error) {
	for _, callback := range callbacks {
		m.InsertCallbacks.BeforeQueryCallback = append(m.InsertCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *OnlyExecServiceMapServer) RegisterInsertAfterQueryCallback(callbacks ...func(queryString string, req *OnlyExec, resp *OnlyExec) error) {
	for _, callback := range callbacks {
		m.InsertCallbacks.AfterQueryCallback = append(m.InsertCallbacks.AfterQueryCallback, callback)
	}
}

func (m *OnlyExecServiceMapServer) RegisterInsertCache(cache func(queryString string, req *OnlyExec) (*OnlyExec, error)) {
	m.InsertCallbacks.Cache = cache
}

func (m *OnlyExecServiceMapServer) Insert(ctx context.Context, r *OnlyExec) (*OnlyExec, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "Insert", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.InsertCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.InsertCallbacks.Cache != nil {
		if resp, err := m.InsertCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n OnlyExec request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	_, err = m.DB.ExecContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n OnlyExec request: %s \n query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	for _, callback := range m.InsertCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, nil); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	resp := OnlyExec{}
	return &resp, nil

}
