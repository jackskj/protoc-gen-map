package mapper

import (
	db "database/sql"
	"errors"
	"fmt"
	"log"
	"reflect"
	"strings"
	"unicode"

	"github.com/golang/protobuf/ptypes/timestamp"
)

var _ = fmt.Errorf
var _ = log.Fatal
var _ = reflect.Append

type (
	mapName    string // Map name corresponds to the proto message name
	columnName string // Name of the column returned by executing SQL
	mapType    int
)

// Map can either be, a top level element (proto response)
// Association, (nested field) or
// Collection, (repeated nested field)
const (
	TopLevelElement mapType = iota
	Association
	Collection
)

var (
	EnumVals map[string]map[string]int32
)

// Representation of SQL response mapping to a proto response message
// protoc-gen-map generates service server methods which implement interfaces generated by protoc-gen-go
// each RPC and therefore SQL has corresponding  Mapper
type Mapper struct {
	SqlMap *SqlMap //Mapping of top level element, proto response message
	Name   string  //Name of the corresponding RPC
	Logs   map[string]bool
	Error  error

	columns     map[columnName]int // columns returned by executing the sql, mapped to their index
	columnTypes []*db.ColumnType   // column types returned by executing the SQL
}

// ProtoField represents one field in a proto struct generated by protoc-gen-go
// used to keep track of its location in the parent struct
type ProtoField struct {
	field *reflect.StructField // StructField of a proto struct
	index int                  // i'th element of the parent struct
}

// SqlMap stores types of proto messages and their corresponding column name
// if the proto message has repeated and/or nested fields, they are recursively stores in
// Associations and Collections
type SqlMap struct {
	Name        mapName      // Name of the corresponging proto message
	MapType     mapType      //
	ProtoStruct reflect.Type // type of the corresponging proto message

	// ProtoStruct for Collections are slices of pointers,
	// if the SqlMap Type is a Collection, this field is the pointer of the underlyiogn struct
	// For top level element and association types, this field is nil
	ProtoSliceElem reflect.Type
	// For collections and association, this the i in reflect.Value.Field(i) where i is the ith field of the SqlMap
	// which corresponds to the Proto Message which holds this association or collection.
	ParentFieldId int

	// Column correspond to proto message field names that match sql columns
	Columns map[columnName]*ProtoField
	// Columns of the SQL response which are present in this proto message
	PresentColumns []string
	//  and those columns' values
	ProtoValues []interface{}

	// Associations are has-one relationships which correspond to nested proto messages
	Associations map[mapName]*SqlMap
	//Collections are has-many relationships which correspond to nested and repeated proto messages
	Collections map[mapName]*SqlMap

	Error error    // breaking issue
	Logs  []string // non-breaking issue
}

// Each RPC call generates ResponseMapping, this is responsible for storing data in structure matching the proto response
type ResponseMapping struct {
	// slice of Top Level Elements, pointers to response messages
	Responses []interface{}

	// values returned by executing SQL query,
	// it is in form of slice of rows
	// each row is a slice of columns
	values [][]interface{}

	//SQL Values of the Top Level Element
	sqlMapVals *SqlMapVals
}

// SQL Values are values returned from the SQL query which belong to a particular proto message.
// Pointers to those messages are stored in UniqueIds
type SqlMapVals struct {
	// Columns values of the SQL response which are present in this proto message
	// this field contained currently analysed values
	ProtoValues []interface{}

	// If all current ProtoValues are nil, isNil is set true and mapping of this element is omitted
	IsNill bool

	// Protoc-gen-map uses all present columns in a particular message to generate a unique id,
	// if successive rows have the same id, it identifies the same element
	// always include a uniquely identifiable column in your query
	//
	// interface{} in this map are pointers to response proto messages
	UniqueIds map[string]interface{}

	// Associations are has-one relationships which correspond to nested proto messages
	Associations map[mapName]*SqlMapVals
	//Collections are has-many relationships which correspond to nested and repeated proto messages
	Collections map[mapName]*SqlMapVals
}

// Generates mapper instance based on proto response type and response of sql query
// This is done once after the first response is retrieved
func New(name string, rows *db.Rows, protoResp interface{}) (*Mapper, error) {
	columns, _ := rows.Columns()
	columnTypes, _ := rows.ColumnTypes()
	sqlMap := SqlMap{
		Name:        mapName(reflect.TypeOf(protoResp).Elem().Name()),
		MapType:     TopLevelElement,
		ProtoStruct: reflect.TypeOf(protoResp),
	}
	mapper := Mapper{
		Name:        name,
		columnTypes: columnTypes,
		SqlMap:      &sqlMap,
		Logs:        make(map[string]bool),
	}
	mapper.columns = make(map[columnName]int)
	for columnIndex, column := range columns {
		mapper.columns[columnName(column)] = columnIndex
	}
	generateSqlMap(&sqlMap, protoResp, columns)
	if sqlMap.Error != nil {
		return nil, sqlMap.Error
	}
	logSqlMap(&sqlMap, name)
	return &mapper, nil
}

// Retrieves all values from the query
func (m *Mapper) GetValues(rows *db.Rows, respMap *ResponseMapping) error {
	defer rows.Close()
	respMap.values = make([][]interface{}, 0)
	for rows.Next() {
		row := make([]interface{}, len(m.columns))
		for i, _ := range row {
			row[i] = new(interface{})
		}
		err := rows.Scan(row...)
		if err != nil {
			return err
		}
		for i, _ := range row {

			row[i] = reflect.Indirect(reflect.ValueOf(row[i])).Interface()
		}
		respMap.values = append(respMap.values, row)
	}
	return nil
}

// Generates SQL mapping recursively according to the proto message and its submessages
// This is done once, after the first sql response is retrieved
func generateSqlMap(sqlMap *SqlMap, protoMsg interface{}, columns []string) {
	var (
		protoStructPtr reflect.Type
		protoStruct    reflect.Type
	)
	if protoType, ok := protoMsg.(reflect.Type); ok {
		protoStructPtr = protoType
	} else {
		protoStructPtr = reflect.TypeOf(protoMsg)
	}

	// if receiving sqlMap type is collection, the protoStruct  received is a slice of pointers
	// Elem() is used to convert from slice of ptr to  ptr
	if protoStructPtr.Kind() == reflect.Slice && sqlMap.MapType == Collection {
		protoStructPtr = protoStructPtr.Elem()
	}
	protoStruct = protoStructPtr.Elem()

	sqlMapColumns := make(map[columnName]*ProtoField)
	sqlMap.Associations = make(map[mapName]*SqlMap)
	sqlMap.Collections = make(map[mapName]*SqlMap)

	containsAllowed := false
	for i := 0; i < protoStruct.NumField(); i++ {
		field := protoStruct.Field(i)
		if isAlowedType(field) == true {
			containsAllowed = true
			for j, c := range columns {
				nameFromTag := getNameFromTag(field.Tag.Get("protobuf"))
				possibleFieldNames := map[string]bool{
					field.Name:                   true, // Proto Field Name
					nameFromTag:                  true, // Go Field Name
					strings.ToLower(nameFromTag): true,
					strings.ToLower(field.Name):  true,
				}
				if _, found := possibleFieldNames[c]; found {
					protoField := ProtoField{
						field: &field,
						index: i,
					}
					sqlMapColumns[columnName(c)] = &protoField
					// remove claimed column
					columns[j] = columns[len(columns)-1]
					columns = columns[:len(columns)-1]
					break
				}

			}
		} else if subMapType, isSubMap, err := isSubMap(field); isSubMap == true {
			if err != nil {
				sqlMap.Error = err
				return
			}
			subMap := SqlMap{
				Name:          mapName(field.Name),
				ProtoStruct:   field.Type,
				ParentFieldId: i,
			}
			if subMapType == "association" {
				subMap.MapType = Association
				generateSqlMap(&subMap, field.Type, columns)
				if subMap.Error != nil {
					sqlMap.Error = subMap.Error
					return
				}
				sqlMap.Associations[mapName(field.Name)] = &subMap
			} else if subMapType == "collection" {
				subMap.MapType = Collection
				subMap.ProtoSliceElem = field.Type.Elem()
				log.Println(protoStruct.Field(i))
				generateSqlMap(&subMap, field.Type, columns)
				if subMap.Error != nil {
					sqlMap.Error = subMap.Error
					return
				}
				sqlMap.Collections[mapName(field.Name)] = &subMap
			}
		}
	}
	if containsAllowed == false {
		sqlMap.Error = errors.New("protoc-gen-map: No allowed fileds were found in " + string(sqlMap.Name) +
			". At least one primative or timestamp.Timestamp filed must be present in a message.")
	} else if len(sqlMapColumns) == 0 {
		sqlMap.Logs = append(sqlMap.Logs, "No allowed fileds were found in "+string(sqlMap.Name)+
			". Message will be ommitted for this query")
	} else {
		sqlMap.Columns = sqlMapColumns
	}
	return
}

// Retrieves the name of the proto field from the proto file
func getNameFromTag(tag string) string {
	args := strings.Split(tag, ",")
	for _, arg := range args {
		if strings.Split(arg, "=")[0] == "name" {
			return strings.Split(arg, "=")[1]
		}
	}
	return ""
}

// Primitive types generated by protoc-gen-go
var allowedKinds = map[reflect.Kind]bool{
	reflect.Float64: true,
	reflect.Float32: true,
	reflect.Int32:   true,
	reflect.Uint32:  true,
	reflect.Int64:   true,
	reflect.Uint64:  true,
	reflect.Bool:    true,
	reflect.String:  true,
}

// Allowed non-primitives
var allowedTypes = map[reflect.Type]bool{
	reflect.TypeOf(&timestamp.Timestamp{}): true,
}

func isAlowedType(field reflect.StructField) bool {
	kind := field.Type.Kind()
	if allowedKinds[kind] == true {
		return true
	} else if kind == reflect.Ptr && allowedTypes[field.Type] {
		return true
	} else if isEnum(field) {
		return true
	} else {
		return false
	}
}

func isEnum(field reflect.StructField) bool {
	if field.Type.Kind() == reflect.Int32 && field.Type.Name() != "int32" {
		return true
	}
	return false
}

// Tests if the struct field is a submap, this is true for nested and repeated fields
// Repeated fields of primitive types or Timestamp/Empty types are not allowed
func isSubMap(field reflect.StructField) (string, bool, error) {
	kind := field.Type.Kind()
	if isProtoInternal(field.Name) == true {
		return "proto_field", false, nil
	} else if kind == reflect.Slice {
		if allowedKinds[field.Type.Elem().Kind()] {
			msg := field.Name + " repeated primitive, " +
				"protoc-gen-map does not allow repeated primitive field type in the proto message, " +
				"please use repeated message of another type for to indicate a has-many relationship"
			return "", true, errors.New(msg)
		} else if allowedTypes[field.Type.Elem()] {
			msg := field.Name + " repeated timestamp, " +
				"protoc-gen-map does not allow repeated Timestamp field type in the proto message, " +
				"please use repeated message of another type for to indicate a has-many relationship"
			return "", true, errors.New(msg)
		} else {
			return "collection", true, nil
		}
	} else if kind == reflect.Ptr {
		return "association", true, nil
	}
	return "", false, nil
}

// Begin mapping the proto response
// This is method is called for SQL query response
func (m *Mapper) MapResponse(respMap *ResponseMapping) error {
	var topLvlElem interface{}
	for _, rowValues := range respMap.values {
		m.prepareProtoValues(rowValues, m.SqlMap, respMap.sqlMapVals)
		if respMap.sqlMapVals.IsNill {
			continue
		}
		existingProtoMsg, uniqueId, isUnique := m.findUniqueResp(m.SqlMap, respMap.sqlMapVals, "")
		if isUnique {
			topLvlElem = reflect.New(m.SqlMap.ProtoStruct.Elem()).Interface()
			respMap.Responses = append(respMap.Responses, topLvlElem)
		} else {
			topLvlElem = existingProtoMsg
		}
		m.MapRow(rowValues, m.SqlMap, respMap.sqlMapVals, topLvlElem, uniqueId)
		if m.Error != nil {
			return m.Error
		}
	}
	return nil
}

// Map a single row of the sql query
// This function starts with the top level element as input parameter,
// and is called recursively for each Association and Collection on the same row
func (m *Mapper) MapRow(rowValues []interface{}, sqlMap *SqlMap, sqlMapVals *SqlMapVals, protoMsg interface{}, uniqueId string) {
	if m.Error != nil {
		return
	}
	var (
		respValue       reflect.Value
		associationElem interface{}
		associationVals *SqlMapVals
		collectionElem  interface{}
		collectionVals  *SqlMapVals
	)
	respValue = reflect.ValueOf(protoMsg).Elem()
	if _, ok := sqlMapVals.UniqueIds[uniqueId]; ok != true {
		sqlMapVals.UniqueIds[uniqueId] = protoMsg
		for i, column := range sqlMap.PresentColumns {
			protoIndex := sqlMap.Columns[columnName(column)].index
			respField := respValue.Field(protoIndex)
			if err := setProto(respField, sqlMapVals.ProtoValues[i]); err != nil {
				m.Error = errors.New(fmt.Sprintf("protoc-gen-map: error setting %s with "+column+
					" column value; "+err.Error(), respValue.Type()))
				return
			}
		}
	}
	for mapName, association := range sqlMap.Associations {
		associationVals = sqlMapVals.Associations[mapName]
		m.prepareProtoValues(rowValues, association, associationVals)
		if associationVals.IsNill {
			continue
		}
		existingProtoMsg, subMapUniqueId, isUnique := m.findUniqueResp(association, associationVals, uniqueId)
		if isUnique {
			newAssociationElem := reflect.New(association.ProtoStruct.Elem())
			if respValue.Field(association.ParentFieldId).IsNil() == false {
				m.Logs[fmt.Sprintf("%s is defined as a nested field, yet it appearers more than once in mapping, "+
					"consider changing its type to nested and repeated field or review your query or schema.",
					association.Name)] = true
			}
			respValue.Field(association.ParentFieldId).Set(newAssociationElem)
			associationElem = newAssociationElem.Interface()
		} else {
			associationElem = existingProtoMsg
		}
		m.MapRow(rowValues, association, sqlMapVals.Associations[mapName], associationElem, subMapUniqueId)
	}
	for mapName, collection := range sqlMap.Collections {
		collectionVals = sqlMapVals.Collections[mapName]
		m.prepareProtoValues(rowValues, collection, collectionVals)
		if collectionVals.IsNill {
			continue
		}
		existingProtoMsg, subMapUniqueId, isUnique := m.findUniqueResp(collection, collectionVals, uniqueId)
		if isUnique {
			newCollectionElem := reflect.New(collection.ProtoSliceElem.Elem())
			respValueField := respValue.Field(collection.ParentFieldId)
			respValueField.Set(
				reflect.Append(
					respValueField,
					newCollectionElem,
				),
			)
			collectionElem = newCollectionElem.Interface()
		} else {
			collectionElem = existingProtoMsg
		}
		m.MapRow(rowValues, collection, sqlMapVals.Collections[mapName], collectionElem, subMapUniqueId)
	}
	return
}

// Preparing copies values from SQL response to SqlMapVals,
// But only those values that belong to the proto message represented in SqlMap
//
// if all values are nil, mapping of the row is skipped,
// this often happens with outer joins
func (m *Mapper) prepareProtoValues(rowValues []interface{}, sqlMap *SqlMap, sqlMapVals *SqlMapVals) {
	if sqlMap.PresentColumns == nil {
		sqlMap.PresentColumns = []string{}
		for name, _ := range m.columns {
			if _, ok := sqlMap.Columns[name]; ok != false {
				sqlMap.PresentColumns = append(sqlMap.PresentColumns, string(name))
			}
		}
	}
	sqlMapVals.ProtoValues = make([]interface{}, len(sqlMap.PresentColumns))
	for i, column := range sqlMap.PresentColumns {
		sqlMapVals.ProtoValues[i] = rowValues[m.columns[columnName(column)]]
	}
	// if all values are nil, skip
	sqlMapVals.IsNill = true
	for _, val := range sqlMapVals.ProtoValues {
		if val != nil {
			sqlMapVals.IsNill = false
			break
		}
	}
}

// Finds if the unique id for particular sql map values has been processed before.
// note that the uniqueId is a function of current proto values and the parent of the object
// TODO: Implement a better hashing function
func (m *Mapper) findUniqueResp(sqlMap *SqlMap, sqlMapVals *SqlMapVals, parentId string) (protoMsg interface{}, uniqueId string, isUnique bool) {
	uniqueId = parentId + getUniqueId(sqlMapVals.ProtoValues...)
	protoMsg, found := sqlMapVals.UniqueIds[uniqueId]
	isUnique = !found
	return
}

// Generates uniqueID based Proto Values.
// TODO: Implement a better hashing function
func getUniqueId(values ...interface{}) string {
	out := ""
	for _, v := range values {
		out = out + fmt.Sprintf("%v|", reflect.Indirect(reflect.ValueOf(v)))
	}
	return out
}

// Generates Response Mapping, an object which stores mapped SQL response values
func (m *Mapper) NewResponseMapping() *ResponseMapping {
	respMap := ResponseMapping{}
	respMap.sqlMapVals = new(SqlMapVals)
	newSubMapVals(m.SqlMap, respMap.sqlMapVals)
	return &respMap
}

// Recursively generates SubMapVals According to the Proto Message Sql Mapping
func newSubMapVals(sqlMap *SqlMap, sqlMapVals *SqlMapVals) {
	sqlMapVals.Associations = make(map[mapName]*SqlMapVals)
	sqlMapVals.Collections = make(map[mapName]*SqlMapVals)
	sqlMapVals.UniqueIds = make(map[string]interface{})

	for mapName, association := range sqlMap.Associations {
		sqlMapVals.Associations[mapName] = new(SqlMapVals)
		newSubMapVals(association, sqlMapVals.Associations[mapName])
	}
	for mapName, collection := range sqlMap.Collections {
		sqlMapVals.Collections[mapName] = new(SqlMapVals)
		newSubMapVals(collection, sqlMapVals.Collections[mapName])
	}
}

func RegisterEnums(enums map[string]map[string]int32) {
	if EnumVals == nil {
		EnumVals = enums
	} else {
		for enumMapName, enumMapVals := range enums {
			EnumVals[enumMapName] = enumMapVals
		}
	}
}

// tests whether the field name is internal to go protobuff
// any field name starting with XXX as well as  unexported fields are considered specific to protos
// this is trucky as this defunition changes with different versions of golang proto generators
func isProtoInternal(fieldName string) bool {
	if fieldName[0:3] == "XXX" {
		return true
	} else if unicode.IsLower(rune(fieldName[0])) { // unexported  fields
		return true
	}
	return false
}

//If non-breaking issues are found while generating sqlmap, this function prints them
func logSqlMap(sqlm *SqlMap, name string) {
	if len(sqlm.Logs) != 0 {
		for _, message := range sqlm.Logs {
			log.Println("protoc-gen-map, " + name + ": " + message)
		}
	}
	for _, associationSubMap := range sqlm.Associations {
		logSqlMap(associationSubMap, name)
	}
	for _, collectionSubMap := range sqlm.Collections {
		logSqlMap(collectionSubMap, name)
	}

}

//If non-breaking issues are found while mapping, this function prints them
func (m *Mapper) Log() {
	if len(m.Logs) != 0 {
		for message, _ := range m.Logs {
			log.Println("protoc-gen-map, " + m.Name + ": " + message)
			delete(m.Logs, message)
		}
	}
}
