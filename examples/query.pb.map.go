// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: examples/query.proto

package examples

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	math "math"

	//protoc-gen-map packages
	bytes "bytes"
	context "context"
	sql "database/sql"
	sprig "github.com/Masterminds/sprig"
	mapper "github.com/jackskj/protoc-gen-map/mapper"
	mappertmpl "github.com/jackskj/protoc-gen-map/templates"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	log "log"
	sync "sync"
	template "text/template"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Code generated by protoc-gen-map. DO NOT EDIT.
// To Use:
// 1. Instantiate MapperServers with sql.DB connection
// 2. Register MapperServer as the gRPC service server
// 3. Begin serving

var EnumValueMaps = map[string]map[string]int32{
	"Section": map[string]int32{
		"cooking":      0,
		"painting":     1,
		"snowboarding": 3,
		"woodworking":  2,
	},
}

func init() {
	mapper.RegisterEnums(EnumValueMaps)
}

type BlogQueryServiceMapServer struct {
	DB      *sql.DB
	Dialect string

	SelectBlogMapper             *mapper.Mapper
	SelectBlogCallbacks          BlogQueryServiceSelectBlogCallbacks
	SelectBlogsMapper            *mapper.Mapper
	SelectBlogsCallbacks         BlogQueryServiceSelectBlogsCallbacks
	SelectDetailedBlogMapper     *mapper.Mapper
	SelectDetailedBlogCallbacks  BlogQueryServiceSelectDetailedBlogCallbacks
	SelectDetailedBlogsMapper    *mapper.Mapper
	SelectDetailedBlogsCallbacks BlogQueryServiceSelectDetailedBlogsCallbacks

	mapperGenMux sync.Mutex
}

type BlogQueryServiceSelectBlogCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *BlogRequest) error
	AfterQueryCallback  []func(queryString string, req *BlogRequest, resp *BlogResponse) error
	Cache               func(queryString string, req *BlogRequest) (*BlogResponse, error)
}

func (m *BlogQueryServiceMapServer) RegisterSelectBlogBeforeQueryCallback(callbacks ...func(queryString string, req *BlogRequest) error) {
	for _, callback := range callbacks {
		m.SelectBlogCallbacks.BeforeQueryCallback = append(m.SelectBlogCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *BlogQueryServiceMapServer) RegisterSelectBlogAfterQueryCallback(callbacks ...func(queryString string, req *BlogRequest, resp *BlogResponse) error) {
	for _, callback := range callbacks {
		m.SelectBlogCallbacks.AfterQueryCallback = append(m.SelectBlogCallbacks.AfterQueryCallback, callback)
	}
}

func (m *BlogQueryServiceMapServer) RegisterSelectBlogCache(cache func(queryString string, req *BlogRequest) (*BlogResponse, error)) {
	m.SelectBlogCallbacks.Cache = cache
}

func (m *BlogQueryServiceMapServer) SelectBlog(ctx context.Context, r *BlogRequest) (*BlogResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "SelectBlog", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.SelectBlogCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.SelectBlogCallbacks.Cache != nil {
		if resp, err := m.SelectBlogCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n BlogRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.Query(preparedSql, args...)
	if err != nil {
		log.Printf("error executing query.\n BlogRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.SelectBlogMapper == nil {
		m.mapperGenMux.Lock()
		m.SelectBlogMapper, err = mapper.New("SelectBlog", rows, &BlogResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating SelectBlogMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating BlogResponse mapping")
		}
		m.SelectBlogMapper.Log()
	}
	respMap := m.SelectBlogMapper.NewResponseMapping()
	if err := m.SelectBlogMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for SelectBlog: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.SelectBlogMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig SelectBlogMapper: %s", err)
		m.SelectBlogMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig BlogResponse")
	}
	var response *BlogResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &BlogResponse{}
	} else {
		response = respMap.Responses[0].(*BlogResponse)
	}
	for _, callback := range m.SelectBlogCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.SelectBlogMapper.Log()
	return response, nil

}

type BlogQueryServiceSelectBlogsCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *BlogIdsRequest) error
	AfterQueryCallback  []func(queryString string, req *BlogIdsRequest, resp []*BlogResponse) error
	Cache               func(queryString string, req *BlogIdsRequest) ([]*BlogResponse, error)
}

func (m *BlogQueryServiceMapServer) RegisterSelectBlogsBeforeQueryCallback(callbacks ...func(queryString string, req *BlogIdsRequest) error) {
	for _, callback := range callbacks {
		m.SelectBlogsCallbacks.BeforeQueryCallback = append(m.SelectBlogsCallbacks.BeforeQueryCallback, callback)

	}
}

func (m *BlogQueryServiceMapServer) RegisterSelectBlogsAfterQueryCallback(callbacks ...func(queryString string, req *BlogIdsRequest, resp []*BlogResponse) error) {
	for _, callback := range callbacks {
		m.SelectBlogsCallbacks.AfterQueryCallback = append(m.SelectBlogsCallbacks.AfterQueryCallback, callback)
	}
}

func (m *BlogQueryServiceMapServer) RegisterSelectBlogsCache(cache func(queryString string, req *BlogIdsRequest) ([]*BlogResponse, error)) {
	m.SelectBlogsCallbacks.Cache = cache
}

func (m *BlogQueryServiceMapServer) SelectBlogs(r *BlogIdsRequest, stream BlogQueryService_SelectBlogsServer) error {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "SelectBlogs", r); err != nil {
		return status.Error(codes.Internal, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.SelectBlogsCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	if m.SelectBlogsCallbacks.Cache != nil {
		if responses, err := m.SelectBlogsCallbacks.Cache(rawSql, r); err == nil {
			if responses != nil {
				for _, resp := range responses {
					if err := stream.Send(resp); err != nil {
						return status.Error(codes.Internal, err.Error())
					}
				}
				return nil
			}
		} else {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n BlogIdsRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.Query(preparedSql, args...)
	if err != nil {
		log.Printf("error executing query.\n BlogIdsRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.Internal, err.Error())
	} else {
		defer rows.Close()
	}
	if m.SelectBlogsMapper == nil {
		m.mapperGenMux.Lock()
		m.SelectBlogsMapper, err = mapper.New("SelectBlogs", rows, &BlogResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating SelectBlogsMapper: %s", err)
			return status.Error(codes.Internal, "error generating BlogResponse mapping")
		}
		m.SelectBlogsMapper.Log()
	}
	respMap := m.SelectBlogsMapper.NewResponseMapping()
	if err := m.SelectBlogsMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for SelectBlogs: %s", err)
		return status.Error(codes.Internal, "error loading data")
	}
	if err := m.SelectBlogsMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig SelectBlogsMapper: %s", err)
		m.SelectBlogsMapper.Error = nil
		return status.Error(codes.Internal, "error mappig BlogResponse")
	}
	var responses []*BlogResponse
	for _, resp := range respMap.Responses {
		responses = append(responses, resp.(*BlogResponse))
	}
	for _, callback := range m.SelectBlogsCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, responses); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	m.SelectBlogsMapper.Log()
	for _, resp := range responses {
		if err := stream.Send(resp); err != nil {
			return status.Error(codes.Internal, err.Error())
		}
	}
	return nil
}

type BlogQueryServiceSelectDetailedBlogCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *BlogRequest) error
	AfterQueryCallback  []func(queryString string, req *BlogRequest, resp *DetailedBlogResponse) error
	Cache               func(queryString string, req *BlogRequest) (*DetailedBlogResponse, error)
}

func (m *BlogQueryServiceMapServer) RegisterSelectDetailedBlogBeforeQueryCallback(callbacks ...func(queryString string, req *BlogRequest) error) {
	for _, callback := range callbacks {
		m.SelectDetailedBlogCallbacks.BeforeQueryCallback = append(m.SelectDetailedBlogCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *BlogQueryServiceMapServer) RegisterSelectDetailedBlogAfterQueryCallback(callbacks ...func(queryString string, req *BlogRequest, resp *DetailedBlogResponse) error) {
	for _, callback := range callbacks {
		m.SelectDetailedBlogCallbacks.AfterQueryCallback = append(m.SelectDetailedBlogCallbacks.AfterQueryCallback, callback)
	}
}

func (m *BlogQueryServiceMapServer) RegisterSelectDetailedBlogCache(cache func(queryString string, req *BlogRequest) (*DetailedBlogResponse, error)) {
	m.SelectDetailedBlogCallbacks.Cache = cache
}

func (m *BlogQueryServiceMapServer) SelectDetailedBlog(ctx context.Context, r *BlogRequest) (*DetailedBlogResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "SelectDetailedBlog", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.SelectDetailedBlogCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.SelectDetailedBlogCallbacks.Cache != nil {
		if resp, err := m.SelectDetailedBlogCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n BlogRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.Query(preparedSql, args...)
	if err != nil {
		log.Printf("error executing query.\n BlogRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.SelectDetailedBlogMapper == nil {
		m.mapperGenMux.Lock()
		m.SelectDetailedBlogMapper, err = mapper.New("SelectDetailedBlog", rows, &DetailedBlogResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating SelectDetailedBlogMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating DetailedBlogResponse mapping")
		}
		m.SelectDetailedBlogMapper.Log()
	}
	respMap := m.SelectDetailedBlogMapper.NewResponseMapping()
	if err := m.SelectDetailedBlogMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for SelectDetailedBlog: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.SelectDetailedBlogMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig SelectDetailedBlogMapper: %s", err)
		m.SelectDetailedBlogMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig DetailedBlogResponse")
	}
	var response *DetailedBlogResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &DetailedBlogResponse{}
	} else {
		response = respMap.Responses[0].(*DetailedBlogResponse)
	}
	for _, callback := range m.SelectDetailedBlogCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.SelectDetailedBlogMapper.Log()
	return response, nil

}

type BlogQueryServiceSelectDetailedBlogsCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *BlogIdsRequest) error
	AfterQueryCallback  []func(queryString string, req *BlogIdsRequest, resp []*DetailedBlogResponse) error
	Cache               func(queryString string, req *BlogIdsRequest) ([]*DetailedBlogResponse, error)
}

func (m *BlogQueryServiceMapServer) RegisterSelectDetailedBlogsBeforeQueryCallback(callbacks ...func(queryString string, req *BlogIdsRequest) error) {
	for _, callback := range callbacks {
		m.SelectDetailedBlogsCallbacks.BeforeQueryCallback = append(m.SelectDetailedBlogsCallbacks.BeforeQueryCallback, callback)

	}
}

func (m *BlogQueryServiceMapServer) RegisterSelectDetailedBlogsAfterQueryCallback(callbacks ...func(queryString string, req *BlogIdsRequest, resp []*DetailedBlogResponse) error) {
	for _, callback := range callbacks {
		m.SelectDetailedBlogsCallbacks.AfterQueryCallback = append(m.SelectDetailedBlogsCallbacks.AfterQueryCallback, callback)
	}
}

func (m *BlogQueryServiceMapServer) RegisterSelectDetailedBlogsCache(cache func(queryString string, req *BlogIdsRequest) ([]*DetailedBlogResponse, error)) {
	m.SelectDetailedBlogsCallbacks.Cache = cache
}

func (m *BlogQueryServiceMapServer) SelectDetailedBlogs(r *BlogIdsRequest, stream BlogQueryService_SelectDetailedBlogsServer) error {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "SelectDetailedBlogs", r); err != nil {
		return status.Error(codes.Internal, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.SelectDetailedBlogsCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	if m.SelectDetailedBlogsCallbacks.Cache != nil {
		if responses, err := m.SelectDetailedBlogsCallbacks.Cache(rawSql, r); err == nil {
			if responses != nil {
				for _, resp := range responses {
					if err := stream.Send(resp); err != nil {
						return status.Error(codes.Internal, err.Error())
					}
				}
				return nil
			}
		} else {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n BlogIdsRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.Query(preparedSql, args...)
	if err != nil {
		log.Printf("error executing query.\n BlogIdsRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.Internal, err.Error())
	} else {
		defer rows.Close()
	}
	if m.SelectDetailedBlogsMapper == nil {
		m.mapperGenMux.Lock()
		m.SelectDetailedBlogsMapper, err = mapper.New("SelectDetailedBlogs", rows, &DetailedBlogResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating SelectDetailedBlogsMapper: %s", err)
			return status.Error(codes.Internal, "error generating DetailedBlogResponse mapping")
		}
		m.SelectDetailedBlogsMapper.Log()
	}
	respMap := m.SelectDetailedBlogsMapper.NewResponseMapping()
	if err := m.SelectDetailedBlogsMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for SelectDetailedBlogs: %s", err)
		return status.Error(codes.Internal, "error loading data")
	}
	if err := m.SelectDetailedBlogsMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig SelectDetailedBlogsMapper: %s", err)
		m.SelectDetailedBlogsMapper.Error = nil
		return status.Error(codes.Internal, "error mappig DetailedBlogResponse")
	}
	var responses []*DetailedBlogResponse
	for _, resp := range respMap.Responses {
		responses = append(responses, resp.(*DetailedBlogResponse))
	}
	for _, callback := range m.SelectDetailedBlogsCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, responses); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	m.SelectDetailedBlogsMapper.Log()
	for _, resp := range responses {
		if err := stream.Send(resp); err != nil {
			return status.Error(codes.Internal, err.Error())
		}
	}
	return nil
}

type InsertServiceMapServer struct {
	DB      *sql.DB
	Dialect string

	InsertAuthorMapper    *mapper.Mapper
	InsertAuthorCallbacks InsertServiceInsertAuthorCallbacks

	mapperGenMux sync.Mutex
}

type InsertServiceInsertAuthorCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *InsertAuthorRequest) error
	AfterQueryCallback  []func(queryString string, req *InsertAuthorRequest, resp *EmptyResponse) error
	Cache               func(queryString string, req *InsertAuthorRequest) (*EmptyResponse, error)
}

func (m *InsertServiceMapServer) RegisterInsertAuthorBeforeQueryCallback(callbacks ...func(queryString string, req *InsertAuthorRequest) error) {
	for _, callback := range callbacks {
		m.InsertAuthorCallbacks.BeforeQueryCallback = append(m.InsertAuthorCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *InsertServiceMapServer) RegisterInsertAuthorAfterQueryCallback(callbacks ...func(queryString string, req *InsertAuthorRequest, resp *EmptyResponse) error) {
	for _, callback := range callbacks {
		m.InsertAuthorCallbacks.AfterQueryCallback = append(m.InsertAuthorCallbacks.AfterQueryCallback, callback)
	}
}

func (m *InsertServiceMapServer) RegisterInsertAuthorCache(cache func(queryString string, req *InsertAuthorRequest) (*EmptyResponse, error)) {
	m.InsertAuthorCallbacks.Cache = cache
}

func (m *InsertServiceMapServer) InsertAuthor(ctx context.Context, r *InsertAuthorRequest) (*EmptyResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "InsertAuthor", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.InsertAuthorCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.InsertAuthorCallbacks.Cache != nil {
		if resp, err := m.InsertAuthorCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n InsertAuthorRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	_, err = m.DB.Exec(preparedSql, args...)
	if err != nil {
		log.Printf("error executing query.\n InsertAuthorRequest request: %s \n query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	for _, callback := range m.InsertAuthorCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, nil); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	resp := EmptyResponse{}
	return &resp, nil

}

var sqlTemplate, _ = template.New("sqlTemplate").Funcs(sprig.TxtFuncMap()).Funcs(mappertmpl.Funcs()).Parse(`
{{ define "SelectBlog" }}
select
        id,
        title,
        author_id
from blog
where id = {{ param .Id }} limit 1
{{ end }}


{{ define "SelectBlogs" }}
select
        id,
        title,
        author_id
from blog
        where id in (
        {{ .Ids | join " , " }}
        ) or
        title in (
        {{ .Titles | squoteall | join " , " }}
        )
{{ end }}


{{ define "SelectDetailedBlog" }}
        {{template "DetailedBlog" }}
        {{ if .Id }}
                where B.id = {{ param .Id }}
        {{ else if .AuthorId }}
                where B.author_id = {{ param .AuthorId }}
        {{ end }}
{{ end }}


{{ define "SelectDetailedBlogs" }}
        {{ template "DetailedBlog" }}
        where B.id in (
        {{ .Ids | join " , " }}
        ) or
        B.title in (
        {{ .Titles | squoteall | join " , " }}
        )
{{ end }}

{{ define "DetailedBlog" }}
select
        B.id                as  blog_id,
        B.title             as  blog_title,
        A.id                as  author_id,
        A.username          as  author_username,
        A.password          as  author_password,
        A.email             as  author_email,
        A.bio               as  author_bio,
        A.favourite_section as  author_favourite_section,
        P.id                as  post_id,
        P.blog_id           as  post_blog_id,
        P.author_id         as  post_author_id,
        P.created_on        as  post_created_on,
        P.section           as  post_section,
        P.subject           as  post_subject,
        P.draft             as  draft,
        P.body              as  post_body,
        C.id                as  comment_id,
        C.post_id           as  comment_post_id,
        C.comment           as  comment_text,
        T.id                as  tag_id,
        T.name              as  tag_name
from blog B
        left outer join author A    on  B.author_id = A.id
        left outer join post P      on  B.id = P.blog_id
        left outer join comment C   on  P.id = C.post_id
        left outer join post_tag PT on  PT.post_id = P.id
        left outer join tag T       on  PT.tag_id = T.id
{{ end }}


{{define "InsertAuthor" }}
INSERT INTO author
VALUES (
 {{ .Id }},
 {{ .Username | quote }},
 {{ .Password | quote }},
 {{ .Email | quote }},
 {{ .Bio | quote }},
 {{ .FavouriteSection | quote }}
);
{{end}}

`)
