// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: testdata/tests.proto

package testdata

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	_ "github.com/jackskj/protoc-gen-map/examples"
	math "math"

	//protoc-gen-map packages
	bytes "bytes"
	context "context"
	sql "database/sql"
	sprig "github.com/Masterminds/sprig"
	examples "github.com/jackskj/protoc-gen-map/examples"
	mapper "github.com/jackskj/protoc-gen-map/mapper"
	mappertmpl "github.com/jackskj/protoc-gen-map/templates"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	log "log"
	sync "sync"
	template "text/template"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Code generated by protoc-gen-map. DO NOT EDIT.
// To Use:
// 1. Instantiate MapperServers with sql.DB connection
// 2. Register MapperServer as the gRPC service server
// 3. Begin serving

var EnumValueMaps = map[string]map[string]int32{
	"NestedEnumResponse_NestedMsg_NestedEnum": map[string]int32{
		"egg":  1,
		"span": 0,
	},
}

func init() {
	mapper.RegisterEnums(EnumValueMaps)
}

type TestReflectServiceMapServer struct {
	DB      *sql.DB
	Dialect string

	IncorrectTypesMapper    *mapper.Mapper
	IncorrectTypesCallbacks TestReflectServiceIncorrectTypesCallbacks
	TypeCastingMapper       *mapper.Mapper
	TypeCastingCallbacks    TestReflectServiceTypeCastingCallbacks

	mapperGenMux sync.Mutex
}

type TestReflectServiceTypeCastingCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *TypeCastingResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*TypeCastingResponse, error)
}

func (m *TestReflectServiceMapServer) RegisterTypeCastingBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.TypeCastingCallbacks.BeforeQueryCallback = append(m.TypeCastingCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestReflectServiceMapServer) RegisterTypeCastingAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *TypeCastingResponse) error) {
	for _, callback := range callbacks {
		m.TypeCastingCallbacks.AfterQueryCallback = append(m.TypeCastingCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestReflectServiceMapServer) RegisterTypeCastingCache(cache func(queryString string, req *EmptyRequest) (*TypeCastingResponse, error)) {
	m.TypeCastingCallbacks.Cache = cache
}

func (m *TestReflectServiceMapServer) TypeCasting(ctx context.Context, r *EmptyRequest) (*TypeCastingResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "TypeCasting", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.TypeCastingCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.TypeCastingCallbacks.Cache != nil {
		if resp, err := m.TypeCastingCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.TypeCastingMapper == nil {
		m.mapperGenMux.Lock()
		m.TypeCastingMapper, err = mapper.New("TypeCasting", rows, &TypeCastingResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating TypeCastingMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating TypeCastingResponse mapping")
		}
		m.TypeCastingMapper.Log()
	}
	respMap := m.TypeCastingMapper.NewResponseMapping()
	if err := m.TypeCastingMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for TypeCasting: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.TypeCastingMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig TypeCastingMapper: %s", err)
		m.TypeCastingMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig TypeCastingResponse")
	}
	var response *TypeCastingResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &TypeCastingResponse{}
	} else {
		response = respMap.Responses[0].(*TypeCastingResponse)
	}
	for _, callback := range m.TypeCastingCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.TypeCastingMapper.Log()
	return response, nil

}

type TestReflectServiceIncorrectTypesCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *TypeRequest) error
	AfterQueryCallback  []func(queryString string, req *TypeRequest, resp *GoTypesResponse) error
	Cache               func(queryString string, req *TypeRequest) (*GoTypesResponse, error)
}

func (m *TestReflectServiceMapServer) RegisterIncorrectTypesBeforeQueryCallback(callbacks ...func(queryString string, req *TypeRequest) error) {
	for _, callback := range callbacks {
		m.IncorrectTypesCallbacks.BeforeQueryCallback = append(m.IncorrectTypesCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestReflectServiceMapServer) RegisterIncorrectTypesAfterQueryCallback(callbacks ...func(queryString string, req *TypeRequest, resp *GoTypesResponse) error) {
	for _, callback := range callbacks {
		m.IncorrectTypesCallbacks.AfterQueryCallback = append(m.IncorrectTypesCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestReflectServiceMapServer) RegisterIncorrectTypesCache(cache func(queryString string, req *TypeRequest) (*GoTypesResponse, error)) {
	m.IncorrectTypesCallbacks.Cache = cache
}

func (m *TestReflectServiceMapServer) IncorrectTypes(ctx context.Context, r *TypeRequest) (*GoTypesResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "IncorrectTypes", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.IncorrectTypesCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.IncorrectTypesCallbacks.Cache != nil {
		if resp, err := m.IncorrectTypesCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n TypeRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n TypeRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.IncorrectTypesMapper == nil {
		m.mapperGenMux.Lock()
		m.IncorrectTypesMapper, err = mapper.New("IncorrectTypes", rows, &GoTypesResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating IncorrectTypesMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating GoTypesResponse mapping")
		}
		m.IncorrectTypesMapper.Log()
	}
	respMap := m.IncorrectTypesMapper.NewResponseMapping()
	if err := m.IncorrectTypesMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for IncorrectTypes: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.IncorrectTypesMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig IncorrectTypesMapper: %s", err)
		m.IncorrectTypesMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig GoTypesResponse")
	}
	var response *GoTypesResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &GoTypesResponse{}
	} else {
		response = respMap.Responses[0].(*GoTypesResponse)
	}
	for _, callback := range m.IncorrectTypesCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.IncorrectTypesMapper.Log()
	return response, nil

}

type TestMappingServiceMapServer struct {
	DB      *sql.DB
	Dialect string

	AssociationInCollectionMapper    *mapper.Mapper
	AssociationInCollectionCallbacks TestMappingServiceAssociationInCollectionCallbacks
	BlogAMapper                      *mapper.Mapper
	BlogACallbacks                   TestMappingServiceBlogACallbacks
	BlogAFMapper                     *mapper.Mapper
	BlogAFCallbacks                  TestMappingServiceBlogAFCallbacks
	BlogBMapper                      *mapper.Mapper
	BlogBCallbacks                   TestMappingServiceBlogBCallbacks
	BlogBFMapper                     *mapper.Mapper
	BlogBFCallbacks                  TestMappingServiceBlogBFCallbacks
	BlogCMapper                      *mapper.Mapper
	BlogCCallbacks                   TestMappingServiceBlogCCallbacks
	BlogCFMapper                     *mapper.Mapper
	BlogCFCallbacks                  TestMappingServiceBlogCFCallbacks
	BlogsAMapper                     *mapper.Mapper
	BlogsACallbacks                  TestMappingServiceBlogsACallbacks
	BlogsAFMapper                    *mapper.Mapper
	BlogsAFCallbacks                 TestMappingServiceBlogsAFCallbacks
	BlogsBMapper                     *mapper.Mapper
	BlogsBCallbacks                  TestMappingServiceBlogsBCallbacks
	BlogsBFMapper                    *mapper.Mapper
	BlogsBFCallbacks                 TestMappingServiceBlogsBFCallbacks
	BlogsCMapper                     *mapper.Mapper
	BlogsCCallbacks                  TestMappingServiceBlogsCCallbacks
	BlogsCFMapper                    *mapper.Mapper
	BlogsCFCallbacks                 TestMappingServiceBlogsCFCallbacks
	CanceledStreamContextMapper      *mapper.Mapper
	CanceledStreamContextCallbacks   TestMappingServiceCanceledStreamContextCallbacks
	CanceledUnaryContextMapper       *mapper.Mapper
	CanceledUnaryContextCallbacks    TestMappingServiceCanceledUnaryContextCallbacks
	CollectionInAssociationMapper    *mapper.Mapper
	CollectionInAssociationCallbacks TestMappingServiceCollectionInAssociationCallbacks
	EmptyNestedFieldMapper           *mapper.Mapper
	EmptyNestedFieldCallbacks        TestMappingServiceEmptyNestedFieldCallbacks
	EmptyQueryMapper                 *mapper.Mapper
	EmptyQueryCallbacks              TestMappingServiceEmptyQueryCallbacks
	ExecAsQueryMapper                *mapper.Mapper
	ExecAsQueryCallbacks             TestMappingServiceExecAsQueryCallbacks
	InsertQueryAsExecMapper          *mapper.Mapper
	InsertQueryAsExecCallbacks       TestMappingServiceInsertQueryAsExecCallbacks
	MultipleRespForUnaryMapper       *mapper.Mapper
	MultipleRespForUnaryCallbacks    TestMappingServiceMultipleRespForUnaryCallbacks
	NestedEnumMapper                 *mapper.Mapper
	NestedEnumCallbacks              TestMappingServiceNestedEnumCallbacks
	NoMatchingColumnsMapper          *mapper.Mapper
	NoMatchingColumnsCallbacks       TestMappingServiceNoMatchingColumnsCallbacks
	NoRespForUnaryMapper             *mapper.Mapper
	NoRespForUnaryCallbacks          TestMappingServiceNoRespForUnaryCallbacks
	NullResoultsForSubmapsMapper     *mapper.Mapper
	NullResoultsForSubmapsCallbacks  TestMappingServiceNullResoultsForSubmapsCallbacks
	RepeatedAssociationsMapper       *mapper.Mapper
	RepeatedAssociationsCallbacks    TestMappingServiceRepeatedAssociationsCallbacks
	RepeatedEmptyMapper              *mapper.Mapper
	RepeatedEmptyCallbacks           TestMappingServiceRepeatedEmptyCallbacks
	RepeatedPrimativeMapper          *mapper.Mapper
	RepeatedPrimativeCallbacks       TestMappingServiceRepeatedPrimativeCallbacks
	RepeatedTimestampMapper          *mapper.Mapper
	RepeatedTimestampCallbacks       TestMappingServiceRepeatedTimestampCallbacks
	SimpleEnumMapper                 *mapper.Mapper
	SimpleEnumCallbacks              TestMappingServiceSimpleEnumCallbacks
	UnclaimedColumnsMapper           *mapper.Mapper
	UnclaimedColumnsCallbacks        TestMappingServiceUnclaimedColumnsCallbacks

	mapperGenMux sync.Mutex
}

type TestMappingServiceRepeatedAssociationsCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *RepeatedAssociationsResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*RepeatedAssociationsResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterRepeatedAssociationsBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.RepeatedAssociationsCallbacks.BeforeQueryCallback = append(m.RepeatedAssociationsCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterRepeatedAssociationsAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *RepeatedAssociationsResponse) error) {
	for _, callback := range callbacks {
		m.RepeatedAssociationsCallbacks.AfterQueryCallback = append(m.RepeatedAssociationsCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterRepeatedAssociationsCache(cache func(queryString string, req *EmptyRequest) (*RepeatedAssociationsResponse, error)) {
	m.RepeatedAssociationsCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) RepeatedAssociations(ctx context.Context, r *EmptyRequest) (*RepeatedAssociationsResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "RepeatedAssociations", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.RepeatedAssociationsCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.RepeatedAssociationsCallbacks.Cache != nil {
		if resp, err := m.RepeatedAssociationsCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.RepeatedAssociationsMapper == nil {
		m.mapperGenMux.Lock()
		m.RepeatedAssociationsMapper, err = mapper.New("RepeatedAssociations", rows, &RepeatedAssociationsResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating RepeatedAssociationsMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating RepeatedAssociationsResponse mapping")
		}
		m.RepeatedAssociationsMapper.Log()
	}
	respMap := m.RepeatedAssociationsMapper.NewResponseMapping()
	if err := m.RepeatedAssociationsMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for RepeatedAssociations: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.RepeatedAssociationsMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig RepeatedAssociationsMapper: %s", err)
		m.RepeatedAssociationsMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig RepeatedAssociationsResponse")
	}
	var response *RepeatedAssociationsResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &RepeatedAssociationsResponse{}
	} else {
		response = respMap.Responses[0].(*RepeatedAssociationsResponse)
	}
	for _, callback := range m.RepeatedAssociationsCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.RepeatedAssociationsMapper.Log()
	return response, nil

}

type TestMappingServiceEmptyQueryCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *SampleResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*SampleResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterEmptyQueryBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.EmptyQueryCallbacks.BeforeQueryCallback = append(m.EmptyQueryCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterEmptyQueryAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *SampleResponse) error) {
	for _, callback := range callbacks {
		m.EmptyQueryCallbacks.AfterQueryCallback = append(m.EmptyQueryCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterEmptyQueryCache(cache func(queryString string, req *EmptyRequest) (*SampleResponse, error)) {
	m.EmptyQueryCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) EmptyQuery(ctx context.Context, r *EmptyRequest) (*SampleResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "EmptyQuery", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.EmptyQueryCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.EmptyQueryCallbacks.Cache != nil {
		if resp, err := m.EmptyQueryCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.EmptyQueryMapper == nil {
		m.mapperGenMux.Lock()
		m.EmptyQueryMapper, err = mapper.New("EmptyQuery", rows, &SampleResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating EmptyQueryMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating SampleResponse mapping")
		}
		m.EmptyQueryMapper.Log()
	}
	respMap := m.EmptyQueryMapper.NewResponseMapping()
	if err := m.EmptyQueryMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for EmptyQuery: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.EmptyQueryMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig EmptyQueryMapper: %s", err)
		m.EmptyQueryMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig SampleResponse")
	}
	var response *SampleResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &SampleResponse{}
	} else {
		response = respMap.Responses[0].(*SampleResponse)
	}
	for _, callback := range m.EmptyQueryCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.EmptyQueryMapper.Log()
	return response, nil

}

type TestMappingServiceInsertQueryAsExecCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *examples.Author) error
	Cache               func(queryString string, req *EmptyRequest) (*examples.Author, error)
}

func (m *TestMappingServiceMapServer) RegisterInsertQueryAsExecBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.InsertQueryAsExecCallbacks.BeforeQueryCallback = append(m.InsertQueryAsExecCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterInsertQueryAsExecAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *examples.Author) error) {
	for _, callback := range callbacks {
		m.InsertQueryAsExecCallbacks.AfterQueryCallback = append(m.InsertQueryAsExecCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterInsertQueryAsExecCache(cache func(queryString string, req *EmptyRequest) (*examples.Author, error)) {
	m.InsertQueryAsExecCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) InsertQueryAsExec(ctx context.Context, r *EmptyRequest) (*examples.Author, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "InsertQueryAsExec", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.InsertQueryAsExecCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.InsertQueryAsExecCallbacks.Cache != nil {
		if resp, err := m.InsertQueryAsExecCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	_, err = m.DB.ExecContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	for _, callback := range m.InsertQueryAsExecCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, nil); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	resp := examples.Author{}
	return &resp, nil

}

type TestMappingServiceExecAsQueryCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *SampleResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*SampleResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterExecAsQueryBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.ExecAsQueryCallbacks.BeforeQueryCallback = append(m.ExecAsQueryCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterExecAsQueryAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *SampleResponse) error) {
	for _, callback := range callbacks {
		m.ExecAsQueryCallbacks.AfterQueryCallback = append(m.ExecAsQueryCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterExecAsQueryCache(cache func(queryString string, req *EmptyRequest) (*SampleResponse, error)) {
	m.ExecAsQueryCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) ExecAsQuery(ctx context.Context, r *EmptyRequest) (*SampleResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "ExecAsQuery", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.ExecAsQueryCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.ExecAsQueryCallbacks.Cache != nil {
		if resp, err := m.ExecAsQueryCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.ExecAsQueryMapper == nil {
		m.mapperGenMux.Lock()
		m.ExecAsQueryMapper, err = mapper.New("ExecAsQuery", rows, &SampleResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating ExecAsQueryMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating SampleResponse mapping")
		}
		m.ExecAsQueryMapper.Log()
	}
	respMap := m.ExecAsQueryMapper.NewResponseMapping()
	if err := m.ExecAsQueryMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for ExecAsQuery: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.ExecAsQueryMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig ExecAsQueryMapper: %s", err)
		m.ExecAsQueryMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig SampleResponse")
	}
	var response *SampleResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &SampleResponse{}
	} else {
		response = respMap.Responses[0].(*SampleResponse)
	}
	for _, callback := range m.ExecAsQueryCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.ExecAsQueryMapper.Log()
	return response, nil

}

type TestMappingServiceUnclaimedColumnsCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *AuthorUserNameResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*AuthorUserNameResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterUnclaimedColumnsBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.UnclaimedColumnsCallbacks.BeforeQueryCallback = append(m.UnclaimedColumnsCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterUnclaimedColumnsAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *AuthorUserNameResponse) error) {
	for _, callback := range callbacks {
		m.UnclaimedColumnsCallbacks.AfterQueryCallback = append(m.UnclaimedColumnsCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterUnclaimedColumnsCache(cache func(queryString string, req *EmptyRequest) (*AuthorUserNameResponse, error)) {
	m.UnclaimedColumnsCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) UnclaimedColumns(ctx context.Context, r *EmptyRequest) (*AuthorUserNameResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "UnclaimedColumns", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.UnclaimedColumnsCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.UnclaimedColumnsCallbacks.Cache != nil {
		if resp, err := m.UnclaimedColumnsCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.UnclaimedColumnsMapper == nil {
		m.mapperGenMux.Lock()
		m.UnclaimedColumnsMapper, err = mapper.New("UnclaimedColumns", rows, &AuthorUserNameResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating UnclaimedColumnsMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating AuthorUserNameResponse mapping")
		}
		m.UnclaimedColumnsMapper.Log()
	}
	respMap := m.UnclaimedColumnsMapper.NewResponseMapping()
	if err := m.UnclaimedColumnsMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for UnclaimedColumns: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.UnclaimedColumnsMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig UnclaimedColumnsMapper: %s", err)
		m.UnclaimedColumnsMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig AuthorUserNameResponse")
	}
	var response *AuthorUserNameResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &AuthorUserNameResponse{}
	} else {
		response = respMap.Responses[0].(*AuthorUserNameResponse)
	}
	for _, callback := range m.UnclaimedColumnsCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.UnclaimedColumnsMapper.Log()
	return response, nil

}

type TestMappingServiceMultipleRespForUnaryCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *examples.Author) error
	Cache               func(queryString string, req *EmptyRequest) (*examples.Author, error)
}

func (m *TestMappingServiceMapServer) RegisterMultipleRespForUnaryBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.MultipleRespForUnaryCallbacks.BeforeQueryCallback = append(m.MultipleRespForUnaryCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterMultipleRespForUnaryAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *examples.Author) error) {
	for _, callback := range callbacks {
		m.MultipleRespForUnaryCallbacks.AfterQueryCallback = append(m.MultipleRespForUnaryCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterMultipleRespForUnaryCache(cache func(queryString string, req *EmptyRequest) (*examples.Author, error)) {
	m.MultipleRespForUnaryCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) MultipleRespForUnary(ctx context.Context, r *EmptyRequest) (*examples.Author, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "MultipleRespForUnary", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.MultipleRespForUnaryCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.MultipleRespForUnaryCallbacks.Cache != nil {
		if resp, err := m.MultipleRespForUnaryCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.MultipleRespForUnaryMapper == nil {
		m.mapperGenMux.Lock()
		m.MultipleRespForUnaryMapper, err = mapper.New("MultipleRespForUnary", rows, &examples.Author{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating MultipleRespForUnaryMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating examples.Author mapping")
		}
		m.MultipleRespForUnaryMapper.Log()
	}
	respMap := m.MultipleRespForUnaryMapper.NewResponseMapping()
	if err := m.MultipleRespForUnaryMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for MultipleRespForUnary: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.MultipleRespForUnaryMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig MultipleRespForUnaryMapper: %s", err)
		m.MultipleRespForUnaryMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig examples.Author")
	}
	var response *examples.Author
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &examples.Author{}
	} else {
		response = respMap.Responses[0].(*examples.Author)
	}
	for _, callback := range m.MultipleRespForUnaryCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.MultipleRespForUnaryMapper.Log()
	return response, nil

}

type TestMappingServiceNoRespForUnaryCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *examples.Author) error
	Cache               func(queryString string, req *EmptyRequest) (*examples.Author, error)
}

func (m *TestMappingServiceMapServer) RegisterNoRespForUnaryBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.NoRespForUnaryCallbacks.BeforeQueryCallback = append(m.NoRespForUnaryCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterNoRespForUnaryAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *examples.Author) error) {
	for _, callback := range callbacks {
		m.NoRespForUnaryCallbacks.AfterQueryCallback = append(m.NoRespForUnaryCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterNoRespForUnaryCache(cache func(queryString string, req *EmptyRequest) (*examples.Author, error)) {
	m.NoRespForUnaryCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) NoRespForUnary(ctx context.Context, r *EmptyRequest) (*examples.Author, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "NoRespForUnary", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.NoRespForUnaryCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.NoRespForUnaryCallbacks.Cache != nil {
		if resp, err := m.NoRespForUnaryCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.NoRespForUnaryMapper == nil {
		m.mapperGenMux.Lock()
		m.NoRespForUnaryMapper, err = mapper.New("NoRespForUnary", rows, &examples.Author{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating NoRespForUnaryMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating examples.Author mapping")
		}
		m.NoRespForUnaryMapper.Log()
	}
	respMap := m.NoRespForUnaryMapper.NewResponseMapping()
	if err := m.NoRespForUnaryMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for NoRespForUnary: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.NoRespForUnaryMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig NoRespForUnaryMapper: %s", err)
		m.NoRespForUnaryMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig examples.Author")
	}
	var response *examples.Author
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &examples.Author{}
	} else {
		response = respMap.Responses[0].(*examples.Author)
	}
	for _, callback := range m.NoRespForUnaryCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.NoRespForUnaryMapper.Log()
	return response, nil

}

type TestMappingServiceRepeatedPrimativeCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *RepeatedPrimativeResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*RepeatedPrimativeResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterRepeatedPrimativeBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.RepeatedPrimativeCallbacks.BeforeQueryCallback = append(m.RepeatedPrimativeCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterRepeatedPrimativeAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *RepeatedPrimativeResponse) error) {
	for _, callback := range callbacks {
		m.RepeatedPrimativeCallbacks.AfterQueryCallback = append(m.RepeatedPrimativeCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterRepeatedPrimativeCache(cache func(queryString string, req *EmptyRequest) (*RepeatedPrimativeResponse, error)) {
	m.RepeatedPrimativeCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) RepeatedPrimative(ctx context.Context, r *EmptyRequest) (*RepeatedPrimativeResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "RepeatedPrimative", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.RepeatedPrimativeCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.RepeatedPrimativeCallbacks.Cache != nil {
		if resp, err := m.RepeatedPrimativeCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.RepeatedPrimativeMapper == nil {
		m.mapperGenMux.Lock()
		m.RepeatedPrimativeMapper, err = mapper.New("RepeatedPrimative", rows, &RepeatedPrimativeResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating RepeatedPrimativeMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating RepeatedPrimativeResponse mapping")
		}
		m.RepeatedPrimativeMapper.Log()
	}
	respMap := m.RepeatedPrimativeMapper.NewResponseMapping()
	if err := m.RepeatedPrimativeMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for RepeatedPrimative: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.RepeatedPrimativeMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig RepeatedPrimativeMapper: %s", err)
		m.RepeatedPrimativeMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig RepeatedPrimativeResponse")
	}
	var response *RepeatedPrimativeResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &RepeatedPrimativeResponse{}
	} else {
		response = respMap.Responses[0].(*RepeatedPrimativeResponse)
	}
	for _, callback := range m.RepeatedPrimativeCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.RepeatedPrimativeMapper.Log()
	return response, nil

}

type TestMappingServiceRepeatedEmptyCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *RepeatedEmptyResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*RepeatedEmptyResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterRepeatedEmptyBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.RepeatedEmptyCallbacks.BeforeQueryCallback = append(m.RepeatedEmptyCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterRepeatedEmptyAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *RepeatedEmptyResponse) error) {
	for _, callback := range callbacks {
		m.RepeatedEmptyCallbacks.AfterQueryCallback = append(m.RepeatedEmptyCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterRepeatedEmptyCache(cache func(queryString string, req *EmptyRequest) (*RepeatedEmptyResponse, error)) {
	m.RepeatedEmptyCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) RepeatedEmpty(ctx context.Context, r *EmptyRequest) (*RepeatedEmptyResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "RepeatedEmpty", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.RepeatedEmptyCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.RepeatedEmptyCallbacks.Cache != nil {
		if resp, err := m.RepeatedEmptyCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.RepeatedEmptyMapper == nil {
		m.mapperGenMux.Lock()
		m.RepeatedEmptyMapper, err = mapper.New("RepeatedEmpty", rows, &RepeatedEmptyResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating RepeatedEmptyMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating RepeatedEmptyResponse mapping")
		}
		m.RepeatedEmptyMapper.Log()
	}
	respMap := m.RepeatedEmptyMapper.NewResponseMapping()
	if err := m.RepeatedEmptyMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for RepeatedEmpty: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.RepeatedEmptyMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig RepeatedEmptyMapper: %s", err)
		m.RepeatedEmptyMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig RepeatedEmptyResponse")
	}
	var response *RepeatedEmptyResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &RepeatedEmptyResponse{}
	} else {
		response = respMap.Responses[0].(*RepeatedEmptyResponse)
	}
	for _, callback := range m.RepeatedEmptyCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.RepeatedEmptyMapper.Log()
	return response, nil

}

type TestMappingServiceEmptyNestedFieldCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *NestedFieldResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*NestedFieldResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterEmptyNestedFieldBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.EmptyNestedFieldCallbacks.BeforeQueryCallback = append(m.EmptyNestedFieldCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterEmptyNestedFieldAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *NestedFieldResponse) error) {
	for _, callback := range callbacks {
		m.EmptyNestedFieldCallbacks.AfterQueryCallback = append(m.EmptyNestedFieldCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterEmptyNestedFieldCache(cache func(queryString string, req *EmptyRequest) (*NestedFieldResponse, error)) {
	m.EmptyNestedFieldCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) EmptyNestedField(ctx context.Context, r *EmptyRequest) (*NestedFieldResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "EmptyNestedField", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.EmptyNestedFieldCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.EmptyNestedFieldCallbacks.Cache != nil {
		if resp, err := m.EmptyNestedFieldCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.EmptyNestedFieldMapper == nil {
		m.mapperGenMux.Lock()
		m.EmptyNestedFieldMapper, err = mapper.New("EmptyNestedField", rows, &NestedFieldResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating EmptyNestedFieldMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating NestedFieldResponse mapping")
		}
		m.EmptyNestedFieldMapper.Log()
	}
	respMap := m.EmptyNestedFieldMapper.NewResponseMapping()
	if err := m.EmptyNestedFieldMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for EmptyNestedField: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.EmptyNestedFieldMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig EmptyNestedFieldMapper: %s", err)
		m.EmptyNestedFieldMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig NestedFieldResponse")
	}
	var response *NestedFieldResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &NestedFieldResponse{}
	} else {
		response = respMap.Responses[0].(*NestedFieldResponse)
	}
	for _, callback := range m.EmptyNestedFieldCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.EmptyNestedFieldMapper.Log()
	return response, nil

}

type TestMappingServiceNoMatchingColumnsCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *examples.Author) error
	Cache               func(queryString string, req *EmptyRequest) (*examples.Author, error)
}

func (m *TestMappingServiceMapServer) RegisterNoMatchingColumnsBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.NoMatchingColumnsCallbacks.BeforeQueryCallback = append(m.NoMatchingColumnsCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterNoMatchingColumnsAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *examples.Author) error) {
	for _, callback := range callbacks {
		m.NoMatchingColumnsCallbacks.AfterQueryCallback = append(m.NoMatchingColumnsCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterNoMatchingColumnsCache(cache func(queryString string, req *EmptyRequest) (*examples.Author, error)) {
	m.NoMatchingColumnsCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) NoMatchingColumns(ctx context.Context, r *EmptyRequest) (*examples.Author, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "NoMatchingColumns", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.NoMatchingColumnsCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.NoMatchingColumnsCallbacks.Cache != nil {
		if resp, err := m.NoMatchingColumnsCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.NoMatchingColumnsMapper == nil {
		m.mapperGenMux.Lock()
		m.NoMatchingColumnsMapper, err = mapper.New("NoMatchingColumns", rows, &examples.Author{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating NoMatchingColumnsMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating examples.Author mapping")
		}
		m.NoMatchingColumnsMapper.Log()
	}
	respMap := m.NoMatchingColumnsMapper.NewResponseMapping()
	if err := m.NoMatchingColumnsMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for NoMatchingColumns: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.NoMatchingColumnsMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig NoMatchingColumnsMapper: %s", err)
		m.NoMatchingColumnsMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig examples.Author")
	}
	var response *examples.Author
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &examples.Author{}
	} else {
		response = respMap.Responses[0].(*examples.Author)
	}
	for _, callback := range m.NoMatchingColumnsCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.NoMatchingColumnsMapper.Log()
	return response, nil

}

type TestMappingServiceAssociationInCollectionCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *AssociationInCollectionResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*AssociationInCollectionResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterAssociationInCollectionBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.AssociationInCollectionCallbacks.BeforeQueryCallback = append(m.AssociationInCollectionCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterAssociationInCollectionAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *AssociationInCollectionResponse) error) {
	for _, callback := range callbacks {
		m.AssociationInCollectionCallbacks.AfterQueryCallback = append(m.AssociationInCollectionCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterAssociationInCollectionCache(cache func(queryString string, req *EmptyRequest) (*AssociationInCollectionResponse, error)) {
	m.AssociationInCollectionCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) AssociationInCollection(ctx context.Context, r *EmptyRequest) (*AssociationInCollectionResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "AssociationInCollection", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.AssociationInCollectionCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.AssociationInCollectionCallbacks.Cache != nil {
		if resp, err := m.AssociationInCollectionCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.AssociationInCollectionMapper == nil {
		m.mapperGenMux.Lock()
		m.AssociationInCollectionMapper, err = mapper.New("AssociationInCollection", rows, &AssociationInCollectionResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating AssociationInCollectionMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating AssociationInCollectionResponse mapping")
		}
		m.AssociationInCollectionMapper.Log()
	}
	respMap := m.AssociationInCollectionMapper.NewResponseMapping()
	if err := m.AssociationInCollectionMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for AssociationInCollection: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.AssociationInCollectionMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig AssociationInCollectionMapper: %s", err)
		m.AssociationInCollectionMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig AssociationInCollectionResponse")
	}
	var response *AssociationInCollectionResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &AssociationInCollectionResponse{}
	} else {
		response = respMap.Responses[0].(*AssociationInCollectionResponse)
	}
	for _, callback := range m.AssociationInCollectionCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.AssociationInCollectionMapper.Log()
	return response, nil

}

type TestMappingServiceCollectionInAssociationCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *CollectionInAssociationResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*CollectionInAssociationResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterCollectionInAssociationBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.CollectionInAssociationCallbacks.BeforeQueryCallback = append(m.CollectionInAssociationCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterCollectionInAssociationAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *CollectionInAssociationResponse) error) {
	for _, callback := range callbacks {
		m.CollectionInAssociationCallbacks.AfterQueryCallback = append(m.CollectionInAssociationCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterCollectionInAssociationCache(cache func(queryString string, req *EmptyRequest) (*CollectionInAssociationResponse, error)) {
	m.CollectionInAssociationCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) CollectionInAssociation(ctx context.Context, r *EmptyRequest) (*CollectionInAssociationResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "CollectionInAssociation", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.CollectionInAssociationCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.CollectionInAssociationCallbacks.Cache != nil {
		if resp, err := m.CollectionInAssociationCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.CollectionInAssociationMapper == nil {
		m.mapperGenMux.Lock()
		m.CollectionInAssociationMapper, err = mapper.New("CollectionInAssociation", rows, &CollectionInAssociationResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating CollectionInAssociationMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating CollectionInAssociationResponse mapping")
		}
		m.CollectionInAssociationMapper.Log()
	}
	respMap := m.CollectionInAssociationMapper.NewResponseMapping()
	if err := m.CollectionInAssociationMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for CollectionInAssociation: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.CollectionInAssociationMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig CollectionInAssociationMapper: %s", err)
		m.CollectionInAssociationMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig CollectionInAssociationResponse")
	}
	var response *CollectionInAssociationResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &CollectionInAssociationResponse{}
	} else {
		response = respMap.Responses[0].(*CollectionInAssociationResponse)
	}
	for _, callback := range m.CollectionInAssociationCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.CollectionInAssociationMapper.Log()
	return response, nil

}

type TestMappingServiceRepeatedTimestampCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *RepeatedTimestampResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*RepeatedTimestampResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterRepeatedTimestampBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.RepeatedTimestampCallbacks.BeforeQueryCallback = append(m.RepeatedTimestampCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterRepeatedTimestampAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *RepeatedTimestampResponse) error) {
	for _, callback := range callbacks {
		m.RepeatedTimestampCallbacks.AfterQueryCallback = append(m.RepeatedTimestampCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterRepeatedTimestampCache(cache func(queryString string, req *EmptyRequest) (*RepeatedTimestampResponse, error)) {
	m.RepeatedTimestampCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) RepeatedTimestamp(ctx context.Context, r *EmptyRequest) (*RepeatedTimestampResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "RepeatedTimestamp", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.RepeatedTimestampCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.RepeatedTimestampCallbacks.Cache != nil {
		if resp, err := m.RepeatedTimestampCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.RepeatedTimestampMapper == nil {
		m.mapperGenMux.Lock()
		m.RepeatedTimestampMapper, err = mapper.New("RepeatedTimestamp", rows, &RepeatedTimestampResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating RepeatedTimestampMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating RepeatedTimestampResponse mapping")
		}
		m.RepeatedTimestampMapper.Log()
	}
	respMap := m.RepeatedTimestampMapper.NewResponseMapping()
	if err := m.RepeatedTimestampMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for RepeatedTimestamp: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.RepeatedTimestampMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig RepeatedTimestampMapper: %s", err)
		m.RepeatedTimestampMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig RepeatedTimestampResponse")
	}
	var response *RepeatedTimestampResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &RepeatedTimestampResponse{}
	} else {
		response = respMap.Responses[0].(*RepeatedTimestampResponse)
	}
	for _, callback := range m.RepeatedTimestampCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.RepeatedTimestampMapper.Log()
	return response, nil

}

type TestMappingServiceNullResoultsForSubmapsCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp []*examples.Post) error
	Cache               func(queryString string, req *EmptyRequest) ([]*examples.Post, error)
}

func (m *TestMappingServiceMapServer) RegisterNullResoultsForSubmapsBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.NullResoultsForSubmapsCallbacks.BeforeQueryCallback = append(m.NullResoultsForSubmapsCallbacks.BeforeQueryCallback, callback)

	}
}

func (m *TestMappingServiceMapServer) RegisterNullResoultsForSubmapsAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp []*examples.Post) error) {
	for _, callback := range callbacks {
		m.NullResoultsForSubmapsCallbacks.AfterQueryCallback = append(m.NullResoultsForSubmapsCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterNullResoultsForSubmapsCache(cache func(queryString string, req *EmptyRequest) ([]*examples.Post, error)) {
	m.NullResoultsForSubmapsCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) NullResoultsForSubmaps(r *EmptyRequest, stream TestMappingService_NullResoultsForSubmapsServer) error {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "NullResoultsForSubmaps", r); err != nil {
		return status.Error(codes.Internal, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.NullResoultsForSubmapsCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	if m.NullResoultsForSubmapsCallbacks.Cache != nil {
		if responses, err := m.NullResoultsForSubmapsCallbacks.Cache(rawSql, r); err == nil {
			if responses != nil {
				for _, resp := range responses {
					if err := stream.Send(resp); err != nil {
						return status.Error(codes.Internal, err.Error())
					}
				}
				return nil
			}
		} else {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.InvalidArgument, "Request generated malformed query.")
	}
	rows, err := m.DB.QueryContext(stream.Context(), preparedSql, args...)
	if stream.Context().Err() == context.Canceled {
		return status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.Internal, err.Error())
	} else {
		defer rows.Close()
	}
	if m.NullResoultsForSubmapsMapper == nil {
		m.mapperGenMux.Lock()
		m.NullResoultsForSubmapsMapper, err = mapper.New("NullResoultsForSubmaps", rows, &examples.Post{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("Error generating NullResoultsForSubmapsMapper: %s", err)
			return status.Error(codes.Internal, "Error generating examples.Post mapping.")
		}
		m.NullResoultsForSubmapsMapper.Log()
	}
	respMap := m.NullResoultsForSubmapsMapper.NewResponseMapping()
	if err := m.NullResoultsForSubmapsMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for NullResoultsForSubmaps: %s", err)
		return status.Error(codes.Internal, "error loading data")
	}
	if err := m.NullResoultsForSubmapsMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig NullResoultsForSubmapsMapper: %s", err)
		m.NullResoultsForSubmapsMapper.Error = nil
		return status.Error(codes.Internal, "error mappig examples.Post")
	}
	var responses []*examples.Post
	for _, resp := range respMap.Responses {
		responses = append(responses, resp.(*examples.Post))
	}
	for _, callback := range m.NullResoultsForSubmapsCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, responses); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	m.NullResoultsForSubmapsMapper.Log()
	for _, resp := range responses {
		if err := stream.Send(resp); err != nil {
			return status.Error(codes.Internal, err.Error())
		}
	}
	return nil
}

type TestMappingServiceSimpleEnumCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *examples.Author) error
	Cache               func(queryString string, req *EmptyRequest) (*examples.Author, error)
}

func (m *TestMappingServiceMapServer) RegisterSimpleEnumBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.SimpleEnumCallbacks.BeforeQueryCallback = append(m.SimpleEnumCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterSimpleEnumAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *examples.Author) error) {
	for _, callback := range callbacks {
		m.SimpleEnumCallbacks.AfterQueryCallback = append(m.SimpleEnumCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterSimpleEnumCache(cache func(queryString string, req *EmptyRequest) (*examples.Author, error)) {
	m.SimpleEnumCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) SimpleEnum(ctx context.Context, r *EmptyRequest) (*examples.Author, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "SimpleEnum", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.SimpleEnumCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.SimpleEnumCallbacks.Cache != nil {
		if resp, err := m.SimpleEnumCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.SimpleEnumMapper == nil {
		m.mapperGenMux.Lock()
		m.SimpleEnumMapper, err = mapper.New("SimpleEnum", rows, &examples.Author{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating SimpleEnumMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating examples.Author mapping")
		}
		m.SimpleEnumMapper.Log()
	}
	respMap := m.SimpleEnumMapper.NewResponseMapping()
	if err := m.SimpleEnumMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for SimpleEnum: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.SimpleEnumMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig SimpleEnumMapper: %s", err)
		m.SimpleEnumMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig examples.Author")
	}
	var response *examples.Author
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &examples.Author{}
	} else {
		response = respMap.Responses[0].(*examples.Author)
	}
	for _, callback := range m.SimpleEnumCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.SimpleEnumMapper.Log()
	return response, nil

}

type TestMappingServiceNestedEnumCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *NestedEnumResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*NestedEnumResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterNestedEnumBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.NestedEnumCallbacks.BeforeQueryCallback = append(m.NestedEnumCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterNestedEnumAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *NestedEnumResponse) error) {
	for _, callback := range callbacks {
		m.NestedEnumCallbacks.AfterQueryCallback = append(m.NestedEnumCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterNestedEnumCache(cache func(queryString string, req *EmptyRequest) (*NestedEnumResponse, error)) {
	m.NestedEnumCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) NestedEnum(ctx context.Context, r *EmptyRequest) (*NestedEnumResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "NestedEnum", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.NestedEnumCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.NestedEnumCallbacks.Cache != nil {
		if resp, err := m.NestedEnumCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.NestedEnumMapper == nil {
		m.mapperGenMux.Lock()
		m.NestedEnumMapper, err = mapper.New("NestedEnum", rows, &NestedEnumResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating NestedEnumMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating NestedEnumResponse mapping")
		}
		m.NestedEnumMapper.Log()
	}
	respMap := m.NestedEnumMapper.NewResponseMapping()
	if err := m.NestedEnumMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for NestedEnum: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.NestedEnumMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig NestedEnumMapper: %s", err)
		m.NestedEnumMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig NestedEnumResponse")
	}
	var response *NestedEnumResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &NestedEnumResponse{}
	} else {
		response = respMap.Responses[0].(*NestedEnumResponse)
	}
	for _, callback := range m.NestedEnumCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.NestedEnumMapper.Log()
	return response, nil

}

type TestMappingServiceBlogBCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *examples.BlogResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*examples.BlogResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterBlogBBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.BlogBCallbacks.BeforeQueryCallback = append(m.BlogBCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogBAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *examples.BlogResponse) error) {
	for _, callback := range callbacks {
		m.BlogBCallbacks.AfterQueryCallback = append(m.BlogBCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogBCache(cache func(queryString string, req *EmptyRequest) (*examples.BlogResponse, error)) {
	m.BlogBCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) BlogB(ctx context.Context, r *EmptyRequest) (*examples.BlogResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "BlogB", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.BlogBCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.BlogBCallbacks.Cache != nil {
		if resp, err := m.BlogBCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.BlogBMapper == nil {
		m.mapperGenMux.Lock()
		m.BlogBMapper, err = mapper.New("BlogB", rows, &examples.BlogResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating BlogBMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating examples.BlogResponse mapping")
		}
		m.BlogBMapper.Log()
	}
	respMap := m.BlogBMapper.NewResponseMapping()
	if err := m.BlogBMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for BlogB: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.BlogBMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig BlogBMapper: %s", err)
		m.BlogBMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig examples.BlogResponse")
	}
	var response *examples.BlogResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &examples.BlogResponse{}
	} else {
		response = respMap.Responses[0].(*examples.BlogResponse)
	}
	for _, callback := range m.BlogBCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.BlogBMapper.Log()
	return response, nil

}

type TestMappingServiceBlogsBCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp []*examples.BlogResponse) error
	Cache               func(queryString string, req *EmptyRequest) ([]*examples.BlogResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterBlogsBBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.BlogsBCallbacks.BeforeQueryCallback = append(m.BlogsBCallbacks.BeforeQueryCallback, callback)

	}
}

func (m *TestMappingServiceMapServer) RegisterBlogsBAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp []*examples.BlogResponse) error) {
	for _, callback := range callbacks {
		m.BlogsBCallbacks.AfterQueryCallback = append(m.BlogsBCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogsBCache(cache func(queryString string, req *EmptyRequest) ([]*examples.BlogResponse, error)) {
	m.BlogsBCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) BlogsB(r *EmptyRequest, stream TestMappingService_BlogsBServer) error {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "BlogsB", r); err != nil {
		return status.Error(codes.Internal, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.BlogsBCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	if m.BlogsBCallbacks.Cache != nil {
		if responses, err := m.BlogsBCallbacks.Cache(rawSql, r); err == nil {
			if responses != nil {
				for _, resp := range responses {
					if err := stream.Send(resp); err != nil {
						return status.Error(codes.Internal, err.Error())
					}
				}
				return nil
			}
		} else {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.InvalidArgument, "Request generated malformed query.")
	}
	rows, err := m.DB.QueryContext(stream.Context(), preparedSql, args...)
	if stream.Context().Err() == context.Canceled {
		return status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.Internal, err.Error())
	} else {
		defer rows.Close()
	}
	if m.BlogsBMapper == nil {
		m.mapperGenMux.Lock()
		m.BlogsBMapper, err = mapper.New("BlogsB", rows, &examples.BlogResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("Error generating BlogsBMapper: %s", err)
			return status.Error(codes.Internal, "Error generating examples.BlogResponse mapping.")
		}
		m.BlogsBMapper.Log()
	}
	respMap := m.BlogsBMapper.NewResponseMapping()
	if err := m.BlogsBMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for BlogsB: %s", err)
		return status.Error(codes.Internal, "error loading data")
	}
	if err := m.BlogsBMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig BlogsBMapper: %s", err)
		m.BlogsBMapper.Error = nil
		return status.Error(codes.Internal, "error mappig examples.BlogResponse")
	}
	var responses []*examples.BlogResponse
	for _, resp := range respMap.Responses {
		responses = append(responses, resp.(*examples.BlogResponse))
	}
	for _, callback := range m.BlogsBCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, responses); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	m.BlogsBMapper.Log()
	for _, resp := range responses {
		if err := stream.Send(resp); err != nil {
			return status.Error(codes.Internal, err.Error())
		}
	}
	return nil
}

type TestMappingServiceBlogBFCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *examples.BlogResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*examples.BlogResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterBlogBFBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.BlogBFCallbacks.BeforeQueryCallback = append(m.BlogBFCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogBFAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *examples.BlogResponse) error) {
	for _, callback := range callbacks {
		m.BlogBFCallbacks.AfterQueryCallback = append(m.BlogBFCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogBFCache(cache func(queryString string, req *EmptyRequest) (*examples.BlogResponse, error)) {
	m.BlogBFCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) BlogBF(ctx context.Context, r *EmptyRequest) (*examples.BlogResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "BlogBF", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.BlogBFCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.BlogBFCallbacks.Cache != nil {
		if resp, err := m.BlogBFCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.BlogBFMapper == nil {
		m.mapperGenMux.Lock()
		m.BlogBFMapper, err = mapper.New("BlogBF", rows, &examples.BlogResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating BlogBFMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating examples.BlogResponse mapping")
		}
		m.BlogBFMapper.Log()
	}
	respMap := m.BlogBFMapper.NewResponseMapping()
	if err := m.BlogBFMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for BlogBF: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.BlogBFMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig BlogBFMapper: %s", err)
		m.BlogBFMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig examples.BlogResponse")
	}
	var response *examples.BlogResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &examples.BlogResponse{}
	} else {
		response = respMap.Responses[0].(*examples.BlogResponse)
	}
	for _, callback := range m.BlogBFCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.BlogBFMapper.Log()
	return response, nil

}

type TestMappingServiceBlogsBFCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp []*examples.BlogResponse) error
	Cache               func(queryString string, req *EmptyRequest) ([]*examples.BlogResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterBlogsBFBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.BlogsBFCallbacks.BeforeQueryCallback = append(m.BlogsBFCallbacks.BeforeQueryCallback, callback)

	}
}

func (m *TestMappingServiceMapServer) RegisterBlogsBFAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp []*examples.BlogResponse) error) {
	for _, callback := range callbacks {
		m.BlogsBFCallbacks.AfterQueryCallback = append(m.BlogsBFCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogsBFCache(cache func(queryString string, req *EmptyRequest) ([]*examples.BlogResponse, error)) {
	m.BlogsBFCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) BlogsBF(r *EmptyRequest, stream TestMappingService_BlogsBFServer) error {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "BlogsBF", r); err != nil {
		return status.Error(codes.Internal, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.BlogsBFCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	if m.BlogsBFCallbacks.Cache != nil {
		if responses, err := m.BlogsBFCallbacks.Cache(rawSql, r); err == nil {
			if responses != nil {
				for _, resp := range responses {
					if err := stream.Send(resp); err != nil {
						return status.Error(codes.Internal, err.Error())
					}
				}
				return nil
			}
		} else {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.InvalidArgument, "Request generated malformed query.")
	}
	rows, err := m.DB.QueryContext(stream.Context(), preparedSql, args...)
	if stream.Context().Err() == context.Canceled {
		return status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.Internal, err.Error())
	} else {
		defer rows.Close()
	}
	if m.BlogsBFMapper == nil {
		m.mapperGenMux.Lock()
		m.BlogsBFMapper, err = mapper.New("BlogsBF", rows, &examples.BlogResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("Error generating BlogsBFMapper: %s", err)
			return status.Error(codes.Internal, "Error generating examples.BlogResponse mapping.")
		}
		m.BlogsBFMapper.Log()
	}
	respMap := m.BlogsBFMapper.NewResponseMapping()
	if err := m.BlogsBFMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for BlogsBF: %s", err)
		return status.Error(codes.Internal, "error loading data")
	}
	if err := m.BlogsBFMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig BlogsBFMapper: %s", err)
		m.BlogsBFMapper.Error = nil
		return status.Error(codes.Internal, "error mappig examples.BlogResponse")
	}
	var responses []*examples.BlogResponse
	for _, resp := range respMap.Responses {
		responses = append(responses, resp.(*examples.BlogResponse))
	}
	for _, callback := range m.BlogsBFCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, responses); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	m.BlogsBFMapper.Log()
	for _, resp := range responses {
		if err := stream.Send(resp); err != nil {
			return status.Error(codes.Internal, err.Error())
		}
	}
	return nil
}

type TestMappingServiceBlogACallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *examples.BlogResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*examples.BlogResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterBlogABeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.BlogACallbacks.BeforeQueryCallback = append(m.BlogACallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogAAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *examples.BlogResponse) error) {
	for _, callback := range callbacks {
		m.BlogACallbacks.AfterQueryCallback = append(m.BlogACallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogACache(cache func(queryString string, req *EmptyRequest) (*examples.BlogResponse, error)) {
	m.BlogACallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) BlogA(ctx context.Context, r *EmptyRequest) (*examples.BlogResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "BlogA", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.BlogACallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.BlogACallbacks.Cache != nil {
		if resp, err := m.BlogACallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.BlogAMapper == nil {
		m.mapperGenMux.Lock()
		m.BlogAMapper, err = mapper.New("BlogA", rows, &examples.BlogResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating BlogAMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating examples.BlogResponse mapping")
		}
		m.BlogAMapper.Log()
	}
	respMap := m.BlogAMapper.NewResponseMapping()
	if err := m.BlogAMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for BlogA: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.BlogAMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig BlogAMapper: %s", err)
		m.BlogAMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig examples.BlogResponse")
	}
	var response *examples.BlogResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &examples.BlogResponse{}
	} else {
		response = respMap.Responses[0].(*examples.BlogResponse)
	}
	for _, callback := range m.BlogACallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.BlogAMapper.Log()
	return response, nil

}

type TestMappingServiceBlogsACallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp []*examples.BlogResponse) error
	Cache               func(queryString string, req *EmptyRequest) ([]*examples.BlogResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterBlogsABeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.BlogsACallbacks.BeforeQueryCallback = append(m.BlogsACallbacks.BeforeQueryCallback, callback)

	}
}

func (m *TestMappingServiceMapServer) RegisterBlogsAAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp []*examples.BlogResponse) error) {
	for _, callback := range callbacks {
		m.BlogsACallbacks.AfterQueryCallback = append(m.BlogsACallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogsACache(cache func(queryString string, req *EmptyRequest) ([]*examples.BlogResponse, error)) {
	m.BlogsACallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) BlogsA(r *EmptyRequest, stream TestMappingService_BlogsAServer) error {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "BlogsA", r); err != nil {
		return status.Error(codes.Internal, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.BlogsACallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	if m.BlogsACallbacks.Cache != nil {
		if responses, err := m.BlogsACallbacks.Cache(rawSql, r); err == nil {
			if responses != nil {
				for _, resp := range responses {
					if err := stream.Send(resp); err != nil {
						return status.Error(codes.Internal, err.Error())
					}
				}
				return nil
			}
		} else {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.InvalidArgument, "Request generated malformed query.")
	}
	rows, err := m.DB.QueryContext(stream.Context(), preparedSql, args...)
	if stream.Context().Err() == context.Canceled {
		return status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.Internal, err.Error())
	} else {
		defer rows.Close()
	}
	if m.BlogsAMapper == nil {
		m.mapperGenMux.Lock()
		m.BlogsAMapper, err = mapper.New("BlogsA", rows, &examples.BlogResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("Error generating BlogsAMapper: %s", err)
			return status.Error(codes.Internal, "Error generating examples.BlogResponse mapping.")
		}
		m.BlogsAMapper.Log()
	}
	respMap := m.BlogsAMapper.NewResponseMapping()
	if err := m.BlogsAMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for BlogsA: %s", err)
		return status.Error(codes.Internal, "error loading data")
	}
	if err := m.BlogsAMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig BlogsAMapper: %s", err)
		m.BlogsAMapper.Error = nil
		return status.Error(codes.Internal, "error mappig examples.BlogResponse")
	}
	var responses []*examples.BlogResponse
	for _, resp := range respMap.Responses {
		responses = append(responses, resp.(*examples.BlogResponse))
	}
	for _, callback := range m.BlogsACallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, responses); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	m.BlogsAMapper.Log()
	for _, resp := range responses {
		if err := stream.Send(resp); err != nil {
			return status.Error(codes.Internal, err.Error())
		}
	}
	return nil
}

type TestMappingServiceBlogAFCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *examples.BlogResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*examples.BlogResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterBlogAFBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.BlogAFCallbacks.BeforeQueryCallback = append(m.BlogAFCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogAFAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *examples.BlogResponse) error) {
	for _, callback := range callbacks {
		m.BlogAFCallbacks.AfterQueryCallback = append(m.BlogAFCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogAFCache(cache func(queryString string, req *EmptyRequest) (*examples.BlogResponse, error)) {
	m.BlogAFCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) BlogAF(ctx context.Context, r *EmptyRequest) (*examples.BlogResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "BlogAF", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.BlogAFCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.BlogAFCallbacks.Cache != nil {
		if resp, err := m.BlogAFCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.BlogAFMapper == nil {
		m.mapperGenMux.Lock()
		m.BlogAFMapper, err = mapper.New("BlogAF", rows, &examples.BlogResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating BlogAFMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating examples.BlogResponse mapping")
		}
		m.BlogAFMapper.Log()
	}
	respMap := m.BlogAFMapper.NewResponseMapping()
	if err := m.BlogAFMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for BlogAF: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.BlogAFMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig BlogAFMapper: %s", err)
		m.BlogAFMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig examples.BlogResponse")
	}
	var response *examples.BlogResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &examples.BlogResponse{}
	} else {
		response = respMap.Responses[0].(*examples.BlogResponse)
	}
	for _, callback := range m.BlogAFCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.BlogAFMapper.Log()
	return response, nil

}

type TestMappingServiceBlogsAFCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp []*examples.BlogResponse) error
	Cache               func(queryString string, req *EmptyRequest) ([]*examples.BlogResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterBlogsAFBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.BlogsAFCallbacks.BeforeQueryCallback = append(m.BlogsAFCallbacks.BeforeQueryCallback, callback)

	}
}

func (m *TestMappingServiceMapServer) RegisterBlogsAFAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp []*examples.BlogResponse) error) {
	for _, callback := range callbacks {
		m.BlogsAFCallbacks.AfterQueryCallback = append(m.BlogsAFCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogsAFCache(cache func(queryString string, req *EmptyRequest) ([]*examples.BlogResponse, error)) {
	m.BlogsAFCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) BlogsAF(r *EmptyRequest, stream TestMappingService_BlogsAFServer) error {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "BlogsAF", r); err != nil {
		return status.Error(codes.Internal, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.BlogsAFCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	if m.BlogsAFCallbacks.Cache != nil {
		if responses, err := m.BlogsAFCallbacks.Cache(rawSql, r); err == nil {
			if responses != nil {
				for _, resp := range responses {
					if err := stream.Send(resp); err != nil {
						return status.Error(codes.Internal, err.Error())
					}
				}
				return nil
			}
		} else {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.InvalidArgument, "Request generated malformed query.")
	}
	rows, err := m.DB.QueryContext(stream.Context(), preparedSql, args...)
	if stream.Context().Err() == context.Canceled {
		return status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.Internal, err.Error())
	} else {
		defer rows.Close()
	}
	if m.BlogsAFMapper == nil {
		m.mapperGenMux.Lock()
		m.BlogsAFMapper, err = mapper.New("BlogsAF", rows, &examples.BlogResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("Error generating BlogsAFMapper: %s", err)
			return status.Error(codes.Internal, "Error generating examples.BlogResponse mapping.")
		}
		m.BlogsAFMapper.Log()
	}
	respMap := m.BlogsAFMapper.NewResponseMapping()
	if err := m.BlogsAFMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for BlogsAF: %s", err)
		return status.Error(codes.Internal, "error loading data")
	}
	if err := m.BlogsAFMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig BlogsAFMapper: %s", err)
		m.BlogsAFMapper.Error = nil
		return status.Error(codes.Internal, "error mappig examples.BlogResponse")
	}
	var responses []*examples.BlogResponse
	for _, resp := range respMap.Responses {
		responses = append(responses, resp.(*examples.BlogResponse))
	}
	for _, callback := range m.BlogsAFCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, responses); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	m.BlogsAFMapper.Log()
	for _, resp := range responses {
		if err := stream.Send(resp); err != nil {
			return status.Error(codes.Internal, err.Error())
		}
	}
	return nil
}

type TestMappingServiceBlogCCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *examples.BlogResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*examples.BlogResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterBlogCBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.BlogCCallbacks.BeforeQueryCallback = append(m.BlogCCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogCAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *examples.BlogResponse) error) {
	for _, callback := range callbacks {
		m.BlogCCallbacks.AfterQueryCallback = append(m.BlogCCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogCCache(cache func(queryString string, req *EmptyRequest) (*examples.BlogResponse, error)) {
	m.BlogCCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) BlogC(ctx context.Context, r *EmptyRequest) (*examples.BlogResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "BlogC", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.BlogCCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.BlogCCallbacks.Cache != nil {
		if resp, err := m.BlogCCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.BlogCMapper == nil {
		m.mapperGenMux.Lock()
		m.BlogCMapper, err = mapper.New("BlogC", rows, &examples.BlogResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating BlogCMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating examples.BlogResponse mapping")
		}
		m.BlogCMapper.Log()
	}
	respMap := m.BlogCMapper.NewResponseMapping()
	if err := m.BlogCMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for BlogC: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.BlogCMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig BlogCMapper: %s", err)
		m.BlogCMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig examples.BlogResponse")
	}
	var response *examples.BlogResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &examples.BlogResponse{}
	} else {
		response = respMap.Responses[0].(*examples.BlogResponse)
	}
	for _, callback := range m.BlogCCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.BlogCMapper.Log()
	return response, nil

}

type TestMappingServiceBlogsCCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp []*examples.BlogResponse) error
	Cache               func(queryString string, req *EmptyRequest) ([]*examples.BlogResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterBlogsCBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.BlogsCCallbacks.BeforeQueryCallback = append(m.BlogsCCallbacks.BeforeQueryCallback, callback)

	}
}

func (m *TestMappingServiceMapServer) RegisterBlogsCAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp []*examples.BlogResponse) error) {
	for _, callback := range callbacks {
		m.BlogsCCallbacks.AfterQueryCallback = append(m.BlogsCCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogsCCache(cache func(queryString string, req *EmptyRequest) ([]*examples.BlogResponse, error)) {
	m.BlogsCCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) BlogsC(r *EmptyRequest, stream TestMappingService_BlogsCServer) error {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "BlogsC", r); err != nil {
		return status.Error(codes.Internal, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.BlogsCCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	if m.BlogsCCallbacks.Cache != nil {
		if responses, err := m.BlogsCCallbacks.Cache(rawSql, r); err == nil {
			if responses != nil {
				for _, resp := range responses {
					if err := stream.Send(resp); err != nil {
						return status.Error(codes.Internal, err.Error())
					}
				}
				return nil
			}
		} else {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.InvalidArgument, "Request generated malformed query.")
	}
	rows, err := m.DB.QueryContext(stream.Context(), preparedSql, args...)
	if stream.Context().Err() == context.Canceled {
		return status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.Internal, err.Error())
	} else {
		defer rows.Close()
	}
	if m.BlogsCMapper == nil {
		m.mapperGenMux.Lock()
		m.BlogsCMapper, err = mapper.New("BlogsC", rows, &examples.BlogResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("Error generating BlogsCMapper: %s", err)
			return status.Error(codes.Internal, "Error generating examples.BlogResponse mapping.")
		}
		m.BlogsCMapper.Log()
	}
	respMap := m.BlogsCMapper.NewResponseMapping()
	if err := m.BlogsCMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for BlogsC: %s", err)
		return status.Error(codes.Internal, "error loading data")
	}
	if err := m.BlogsCMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig BlogsCMapper: %s", err)
		m.BlogsCMapper.Error = nil
		return status.Error(codes.Internal, "error mappig examples.BlogResponse")
	}
	var responses []*examples.BlogResponse
	for _, resp := range respMap.Responses {
		responses = append(responses, resp.(*examples.BlogResponse))
	}
	for _, callback := range m.BlogsCCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, responses); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	m.BlogsCMapper.Log()
	for _, resp := range responses {
		if err := stream.Send(resp); err != nil {
			return status.Error(codes.Internal, err.Error())
		}
	}
	return nil
}

type TestMappingServiceBlogCFCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *examples.BlogResponse) error
	Cache               func(queryString string, req *EmptyRequest) (*examples.BlogResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterBlogCFBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.BlogCFCallbacks.BeforeQueryCallback = append(m.BlogCFCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogCFAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *examples.BlogResponse) error) {
	for _, callback := range callbacks {
		m.BlogCFCallbacks.AfterQueryCallback = append(m.BlogCFCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogCFCache(cache func(queryString string, req *EmptyRequest) (*examples.BlogResponse, error)) {
	m.BlogCFCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) BlogCF(ctx context.Context, r *EmptyRequest) (*examples.BlogResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "BlogCF", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.BlogCFCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.BlogCFCallbacks.Cache != nil {
		if resp, err := m.BlogCFCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.BlogCFMapper == nil {
		m.mapperGenMux.Lock()
		m.BlogCFMapper, err = mapper.New("BlogCF", rows, &examples.BlogResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating BlogCFMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating examples.BlogResponse mapping")
		}
		m.BlogCFMapper.Log()
	}
	respMap := m.BlogCFMapper.NewResponseMapping()
	if err := m.BlogCFMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for BlogCF: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.BlogCFMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig BlogCFMapper: %s", err)
		m.BlogCFMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig examples.BlogResponse")
	}
	var response *examples.BlogResponse
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &examples.BlogResponse{}
	} else {
		response = respMap.Responses[0].(*examples.BlogResponse)
	}
	for _, callback := range m.BlogCFCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.BlogCFMapper.Log()
	return response, nil

}

type TestMappingServiceBlogsCFCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp []*examples.BlogResponse) error
	Cache               func(queryString string, req *EmptyRequest) ([]*examples.BlogResponse, error)
}

func (m *TestMappingServiceMapServer) RegisterBlogsCFBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.BlogsCFCallbacks.BeforeQueryCallback = append(m.BlogsCFCallbacks.BeforeQueryCallback, callback)

	}
}

func (m *TestMappingServiceMapServer) RegisterBlogsCFAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp []*examples.BlogResponse) error) {
	for _, callback := range callbacks {
		m.BlogsCFCallbacks.AfterQueryCallback = append(m.BlogsCFCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterBlogsCFCache(cache func(queryString string, req *EmptyRequest) ([]*examples.BlogResponse, error)) {
	m.BlogsCFCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) BlogsCF(r *EmptyRequest, stream TestMappingService_BlogsCFServer) error {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "BlogsCF", r); err != nil {
		return status.Error(codes.Internal, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.BlogsCFCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	if m.BlogsCFCallbacks.Cache != nil {
		if responses, err := m.BlogsCFCallbacks.Cache(rawSql, r); err == nil {
			if responses != nil {
				for _, resp := range responses {
					if err := stream.Send(resp); err != nil {
						return status.Error(codes.Internal, err.Error())
					}
				}
				return nil
			}
		} else {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.InvalidArgument, "Request generated malformed query.")
	}
	rows, err := m.DB.QueryContext(stream.Context(), preparedSql, args...)
	if stream.Context().Err() == context.Canceled {
		return status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.Internal, err.Error())
	} else {
		defer rows.Close()
	}
	if m.BlogsCFMapper == nil {
		m.mapperGenMux.Lock()
		m.BlogsCFMapper, err = mapper.New("BlogsCF", rows, &examples.BlogResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("Error generating BlogsCFMapper: %s", err)
			return status.Error(codes.Internal, "Error generating examples.BlogResponse mapping.")
		}
		m.BlogsCFMapper.Log()
	}
	respMap := m.BlogsCFMapper.NewResponseMapping()
	if err := m.BlogsCFMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for BlogsCF: %s", err)
		return status.Error(codes.Internal, "error loading data")
	}
	if err := m.BlogsCFMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig BlogsCFMapper: %s", err)
		m.BlogsCFMapper.Error = nil
		return status.Error(codes.Internal, "error mappig examples.BlogResponse")
	}
	var responses []*examples.BlogResponse
	for _, resp := range respMap.Responses {
		responses = append(responses, resp.(*examples.BlogResponse))
	}
	for _, callback := range m.BlogsCFCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, responses); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	m.BlogsCFMapper.Log()
	for _, resp := range responses {
		if err := stream.Send(resp); err != nil {
			return status.Error(codes.Internal, err.Error())
		}
	}
	return nil
}

type TestMappingServiceCanceledUnaryContextCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp *examples.Post) error
	Cache               func(queryString string, req *EmptyRequest) (*examples.Post, error)
}

func (m *TestMappingServiceMapServer) RegisterCanceledUnaryContextBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.CanceledUnaryContextCallbacks.BeforeQueryCallback = append(m.CanceledUnaryContextCallbacks.BeforeQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterCanceledUnaryContextAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp *examples.Post) error) {
	for _, callback := range callbacks {
		m.CanceledUnaryContextCallbacks.AfterQueryCallback = append(m.CanceledUnaryContextCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterCanceledUnaryContextCache(cache func(queryString string, req *EmptyRequest) (*examples.Post, error)) {
	m.CanceledUnaryContextCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) CanceledUnaryContext(ctx context.Context, r *EmptyRequest) (*examples.Post, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "CanceledUnaryContext", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.CanceledUnaryContextCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	if m.CanceledUnaryContextCallbacks.Cache != nil {
		if resp, err := m.CanceledUnaryContextCallbacks.Cache(rawSql, r); err == nil {
			if resp != nil {
				return resp, nil
			}
		} else {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	rows, err := m.DB.QueryContext(ctx, preparedSql, args...)
	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, preparedSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	} else {
		defer rows.Close()
	}
	if m.CanceledUnaryContextMapper == nil {
		m.mapperGenMux.Lock()
		m.CanceledUnaryContextMapper, err = mapper.New("CanceledUnaryContext", rows, &examples.Post{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating CanceledUnaryContextMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating examples.Post mapping")
		}
		m.CanceledUnaryContextMapper.Log()
	}
	respMap := m.CanceledUnaryContextMapper.NewResponseMapping()
	if err := m.CanceledUnaryContextMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for CanceledUnaryContext: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.CanceledUnaryContextMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig CanceledUnaryContextMapper: %s", err)
		m.CanceledUnaryContextMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig examples.Post")
	}
	var response *examples.Post
	if len(respMap.Responses) == 0 {
		//No Responses found
		response = &examples.Post{}
	} else {
		response = respMap.Responses[0].(*examples.Post)
	}
	for _, callback := range m.CanceledUnaryContextCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, response); err != nil {
			log.Println(err.Error())
			return nil, status.Error(codes.Internal, err.Error())
		}
	}
	m.CanceledUnaryContextMapper.Log()
	return response, nil

}

type TestMappingServiceCanceledStreamContextCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *EmptyRequest) error
	AfterQueryCallback  []func(queryString string, req *EmptyRequest, resp []*examples.Post) error
	Cache               func(queryString string, req *EmptyRequest) ([]*examples.Post, error)
}

func (m *TestMappingServiceMapServer) RegisterCanceledStreamContextBeforeQueryCallback(callbacks ...func(queryString string, req *EmptyRequest) error) {
	for _, callback := range callbacks {
		m.CanceledStreamContextCallbacks.BeforeQueryCallback = append(m.CanceledStreamContextCallbacks.BeforeQueryCallback, callback)

	}
}

func (m *TestMappingServiceMapServer) RegisterCanceledStreamContextAfterQueryCallback(callbacks ...func(queryString string, req *EmptyRequest, resp []*examples.Post) error) {
	for _, callback := range callbacks {
		m.CanceledStreamContextCallbacks.AfterQueryCallback = append(m.CanceledStreamContextCallbacks.AfterQueryCallback, callback)
	}
}

func (m *TestMappingServiceMapServer) RegisterCanceledStreamContextCache(cache func(queryString string, req *EmptyRequest) ([]*examples.Post, error)) {
	m.CanceledStreamContextCallbacks.Cache = cache
}

func (m *TestMappingServiceMapServer) CanceledStreamContext(r *EmptyRequest, stream TestMappingService_CanceledStreamContextServer) error {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "CanceledStreamContext", r); err != nil {
		return status.Error(codes.Internal, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.CanceledStreamContextCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	if m.CanceledStreamContextCallbacks.Cache != nil {
		if responses, err := m.CanceledStreamContextCallbacks.Cache(rawSql, r); err == nil {
			if responses != nil {
				for _, resp := range responses {
					if err := stream.Send(resp); err != nil {
						return status.Error(codes.Internal, err.Error())
					}
				}
				return nil
			}
		} else {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.InvalidArgument, "Request generated malformed query.")
	}
	rows, err := m.DB.QueryContext(stream.Context(), preparedSql, args...)
	if stream.Context().Err() == context.Canceled {
		return status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.Internal, err.Error())
	} else {
		defer rows.Close()
	}
	if m.CanceledStreamContextMapper == nil {
		m.mapperGenMux.Lock()
		m.CanceledStreamContextMapper, err = mapper.New("CanceledStreamContext", rows, &examples.Post{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("Error generating CanceledStreamContextMapper: %s", err)
			return status.Error(codes.Internal, "Error generating examples.Post mapping.")
		}
		m.CanceledStreamContextMapper.Log()
	}
	respMap := m.CanceledStreamContextMapper.NewResponseMapping()
	if err := m.CanceledStreamContextMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for CanceledStreamContext: %s", err)
		return status.Error(codes.Internal, "error loading data")
	}
	if err := m.CanceledStreamContextMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig CanceledStreamContextMapper: %s", err)
		m.CanceledStreamContextMapper.Error = nil
		return status.Error(codes.Internal, "error mappig examples.Post")
	}
	var responses []*examples.Post
	for _, resp := range respMap.Responses {
		responses = append(responses, resp.(*examples.Post))
	}
	for _, callback := range m.CanceledStreamContextCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, responses); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	m.CanceledStreamContextMapper.Log()
	for _, resp := range responses {
		if err := stream.Send(resp); err != nil {
			return status.Error(codes.Internal, err.Error())
		}
	}
	return nil
}

var sqlTemplate, _ = template.New("sqlTemplate").Funcs(sprig.TxtFuncMap()).Funcs(mappertmpl.Funcs()).Parse(`
{{ define "RepeatedAssociations" }}
select
       B.id         as  blog_id,
       P.id         as  post_id,
       P.blog_id    as  post_blog_id,
       P.author_id  as  post_author_id,
       P.created_on as  post_created_on,
       P.section    as  post_section,
       P.subject    as  post_subject,
       P.draft      as  draft,
       P.body       as  post_body
from blog B
       left outer join post P on  B.id = P.blog_id
where B.id = 1
{{ end }}

{{ define "EmptyQuery" }}
{{ end }}

{{ define "InsertQueryAsExec" }}
select
       A.username          as  author_username,
       A.password          as  author_password,
       A.email             as  author_email,
       A.bio               as  author_bio,
       A.favourite_section as  author_favourite_section
from author A where id = 1
{{ end }}

{{ define "ExecAsQuery" }}
drop table if exists execasquery;
create table execasquery
(
  id                int
);
{{ end }}

{{ define "UnclaimedColumns" }}
select
       A.username          as  author_username,
       A.password          as  author_password
from author A where id = 1
{{ end }}

{{ define "MultipleRespForUnary" }}
select
       A.username          as  author_username,
       A.password          as  author_password,
       A.email             as  author_email,
       A.bio               as  author_bio,
       A.favourite_section as  author_favourite_section
from author A where id in (1,2)
{{ end }}

{{ define "NoRespForUnary" }}
select
       A.username          as  author_username,
       A.password          as  author_password,
       A.email             as  author_email,
       A.bio               as  author_bio,
       A.favourite_section as  author_favourite_section
from author A where id in (999)
{{ end }}

{{ define "RepeatedPrimative" }}
{{ end }}

{{ define "RepeatedEmpty" }}
select id as blog_id from blog limit 1
{{ end }}

{{ define "RepeatedTimestamp" }}
select
       B.id         as  blog_id,
       P.created_on as  post_created_on
from blog B
       left outer join post P on  B.id = P.blog_id
{{ end }}

{{ define "EmptyNestedField" }}
select id as  blog_id from blog limit 1
{{ end }}


{{ define "NoMatchingColumns" }}
select
       B.id as  blog_id,
       B.title as  blog_title
from blog B
{{ end }}

{{ define "AssociationInCollection" }}
select
        T.id as tag_id,
        P.id as post_id,
        B.id as blog_id
from tag T
        left outer join post_tag PT on PT.tag_id = T.id
        left outer join post P      on PT.post_id = P.id
        left outer join blog B      on P.blog_id = B.id
where T.id = 1
{{ end }}

{{ define "CollectionInAssociation" }}
select
        1 as dummy_var,
        B.id as  blog_id,
        B.title as  blog_title,
        A.id                as  author_id,
        A.username          as  author_username,
        A.password          as  author_password,
        A.email             as  author_email,
        A.bio               as  author_bio,
        A.favourite_section as  author_favourite_section
from blog B
       left outer join author A on  B.author_id = A.id
{{ end }}

{{ define "NullResoultsForSubmaps" }}
select
        PT.post_id as  post_id,
        P.id       as  id,
        C.id       as  comment_id,
        C.post_id  as  comment_post_id,
        C.comment  as  comment_text
from post_tag PT
       left outer join post P      on  PT.post_id = P.id
       left outer join comment C   on  P.id = C.post_id
where C.comment is null
{{ end }}

{{ define "SimpleEnum" }}
select
       A.username          as  author_username,
       A.password          as  author_password,
       A.email             as  author_email,
       A.bio               as  author_bio,
       A.favourite_section as  author_favourite_section
from author A where id = 3
{{ end }}

{{ define "NestedEnum" }}
select
        1 as id,
        2 as nested_id,
        'egg' as nested_enum
{{ end }}

{{ define "Blog" }}
select id from blog B order by id limit 1
{{ end }}

{{ define "Blogs" }}
select id from blog B order by id
{{ end }}

{{ define "BlogB" }}
{{ template "Blog" }}
{{ end }}

{{ define "BlogsB" }}
{{ template "Blogs" }}
{{ end }}

{{ define "BlogBF" }}
{{ template "Blog" }}
{{ end }}

{{ define "BlogsBF" }}
{{ template "Blogs" }}
{{ end }}

{{ define "BlogA" }}
{{ template "Blog" }}
{{ end }}

{{ define "BlogsA" }}
{{ template "Blogs" }}
{{ end }}

{{ define "BlogAF" }}
{{ template "Blog" }}
{{ end }}

{{ define "BlogsAF" }}
{{ template "Blogs" }}
{{ end }}

{{ define "BlogC" }}
{{ template "Blog" }}
{{ end }}

{{ define "BlogsC" }}
{{ template "Blogs" }}
{{ end }}

{{ define "BlogCF" }}
{{ template "Blog" }}
{{ end }}

{{ define "BlogsCF" }}
{{ template "Blogs" }}
{{ end }}

{{ define "CanceledUnaryContext" }}
select pg_sleep(15)
{{ end }}

{{ define "CanceledStreamContext" }}
select pg_sleep(15)
{{ end }}
{{ define "TypeCasting" }}
select
	1.1  as  double_cast,  -- float64 also testing name mapping
	1.1  as  FloatCast,    -- float32
	1    as  Int32Cast,    -- int32
	1    as  Int64Cast,    -- int64
	1    as  Uint32Cast,   -- uint32
	1    as  Uint64Cast,   -- uint64
	1    as  Sint32Cast,   -- int32
	1    as  Sint64Cast,   -- int64
	1    as  Fixed32Cast,  -- uint32
	1    as  Fixed64Cast,  -- uint64
	1    as  Sfixed32Cast, -- int32
	1    as  Sfixed64Cast, -- int64
	true as  BoolCast,     -- bool
	'1'  as  StringCast,   -- string
        P.created_on as TimestampCast --time.Time
from post P limit 1
{{ end }}

{{ define "IncorrectTypes" }}
select
        {{ .TypeValue }} as GoFloat64,
        {{ .TypeValue }} as GoFloat32,
        {{ .TypeValue }} as GoInt32,
        {{ .TypeValue }} as GoInt64,
        {{ .TypeValue }} as GoUint32,
        {{ .TypeValue }} as GoUint64,
        {{ .TypeValue }} as GoBool,
        {{ .TypeValue }} as GoString,
        {{ .TypeValue }} as GoTimestamp
        {{ if eq .TypeValue "created_on" }}
        from post limit 1
        {{ end }}
{{ end }}

`)
