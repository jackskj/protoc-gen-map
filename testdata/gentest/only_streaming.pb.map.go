// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: testdata/gentest/only_streaming.proto

package gentest

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	math "math"

	//protoc-gen-map packages
	bytes "bytes"
	context "context"
	sql "database/sql"
	sprig "github.com/Masterminds/sprig"
	mapper "github.com/jackskj/protoc-gen-map/mapper"
	mappertmpl "github.com/jackskj/protoc-gen-map/templates"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	log "log"
	sync "sync"
	template "text/template"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Code generated by protoc-gen-map. DO NOT EDIT.
// To Use:
// 1. Instantiate MapperServers with sql.DB connection
// 2. Register MapperServer as the gRPC service server
// 3. Begin serving

type OnlyStreamingServiceMapServer struct {
	DB      *sql.DB
	Dialect string

	StreamMapper    *mapper.Mapper
	StreamCallbacks OnlyStreamingServiceStreamCallbacks

	mapperGenMux sync.Mutex
}

type OnlyStreamingServiceStreamCallbacks struct {
	BeforeQueryCallback []func(queryString string, req *OnlyStreaming) error
	AfterQueryCallback  []func(queryString string, req *OnlyStreaming, resp []*OnlyStreaming) error
	Cache               func(queryString string, req *OnlyStreaming) ([]*OnlyStreaming, error)
}

func (m *OnlyStreamingServiceMapServer) RegisterStreamBeforeQueryCallback(callbacks ...func(queryString string, req *OnlyStreaming) error) {
	for _, callback := range callbacks {
		m.StreamCallbacks.BeforeQueryCallback = append(m.StreamCallbacks.BeforeQueryCallback, callback)

	}
}

func (m *OnlyStreamingServiceMapServer) RegisterStreamAfterQueryCallback(callbacks ...func(queryString string, req *OnlyStreaming, resp []*OnlyStreaming) error) {
	for _, callback := range callbacks {
		m.StreamCallbacks.AfterQueryCallback = append(m.StreamCallbacks.AfterQueryCallback, callback)
	}
}

func (m *OnlyStreamingServiceMapServer) RegisterStreamCache(cache func(queryString string, req *OnlyStreaming) ([]*OnlyStreaming, error)) {
	m.StreamCallbacks.Cache = cache
}

func (m *OnlyStreamingServiceMapServer) Stream(r *OnlyStreaming, stream OnlyStreamingService_StreamServer) error {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "Stream", r); err != nil {
		return status.Error(codes.Internal, err.Error())
	}
	rawSql := sqlBuffer.String()
	for _, callback := range m.StreamCallbacks.BeforeQueryCallback {
		if err := callback(rawSql, r); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	if m.StreamCallbacks.Cache != nil {
		if responses, err := m.StreamCallbacks.Cache(rawSql, r); err == nil {
			if responses != nil {
				for _, resp := range responses {
					if err := stream.Send(resp); err != nil {
						return status.Error(codes.Internal, err.Error())
					}
				}
				return nil
			}
		} else {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	preparedSql, args, err := mapper.PrepareQuery(m.Dialect, sqlBuffer.Bytes())
	if err != nil {
		log.Printf("error preparing sql query.\n OnlyStreaming request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.InvalidArgument, "Request generated malformed query.")
	}
	rows, err := m.DB.QueryContext(stream.Context(), preparedSql, args...)
	if stream.Context().Err() == context.Canceled {
		return status.Error(codes.Canceled, "Client cancelled.")
	} else if err != nil {
		log.Printf("error executing query.\n OnlyStreaming request: %s \n query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.Internal, err.Error())
	} else {
		defer rows.Close()
	}
	if m.StreamMapper == nil {
		m.mapperGenMux.Lock()
		m.StreamMapper, err = mapper.New("Stream", rows, &OnlyStreaming{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("Error generating StreamMapper: %s", err)
			return status.Error(codes.Internal, "Error generating OnlyStreaming mapping.")
		}
		m.StreamMapper.Log()
	}
	respMap := m.StreamMapper.NewResponseMapping()
	if err := m.StreamMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for Stream: %s", err)
		return status.Error(codes.Internal, "error loading data")
	}
	if err := m.StreamMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig StreamMapper: %s", err)
		m.StreamMapper.Error = nil
		return status.Error(codes.Internal, "error mappig OnlyStreaming")
	}
	var responses []*OnlyStreaming
	for _, resp := range respMap.Responses {
		responses = append(responses, resp.(*OnlyStreaming))
	}
	for _, callback := range m.StreamCallbacks.AfterQueryCallback {
		if err := callback(rawSql, r, responses); err != nil {
			log.Println(err.Error())
			return status.Error(codes.Internal, err.Error())
		}
	}
	m.StreamMapper.Log()
	for _, resp := range responses {
		if err := stream.Send(resp); err != nil {
			return status.Error(codes.Internal, err.Error())
		}
	}
	return nil
}

var sqlTemplate, _ = template.New("sqlTemplate").Funcs(sprig.TxtFuncMap()).Funcs(mappertmpl.Funcs()).Parse(`
{{ define "EmptyService" }}
{{ end }}
{{ define "Stream" }}
{{ end }}
{{ define "Insert" }}
{{ end }}
{{ define "Query" }}
{{ end }}
{{ define "ExecOne" }}
{{ end }}
{{ define "ExecTwo" }}
{{ end }}
{{ define "ExecThree" }}
{{ end }}
{{ define "ExecFour" }}
{{ end }}
{{ define "ExecFive" }}
{{ end }}
{{ define "Insert" }}
{{ end }}
{{ define "InSeRt" }}
{{ end }}
{{ define "Insert" }}
{{ end }}
{{ define "Delete" }}
{{ end }}
{{ define "Update" }}
{{ end }}
{{ define "Create" }}
{{ end }}
{{ define "SubDirectoryTest" }}
{{ end }}

`)
